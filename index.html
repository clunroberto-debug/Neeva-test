<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Neeva â€“ Core Combat Test (Crit incluso)</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
    }
    header {
      padding: 10px 16px;
      background: #020617;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      font-size: 18px;
      margin: 0;
    }
    header small {
      color: #9ca3af;
    }
    main {
      padding: 12px;
      display: grid;
      grid-template-columns: 1.3fr 0.7fr;
      gap: 12px;
    }
    .column {
      background: #020617;
      border-radius: 8px;
      padding: 10px;
      border: 1px solid #1f2937;
    }
    .section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
      border-bottom: 1px solid #1f2937;
      padding-bottom: 4px;
    }
    .team {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .char-card {
      background: #111827;
      border-radius: 6px;
      padding: 6px;
      border: 1px solid #374151;
      width: 190px;
      font-size: 11px;
    }
    .char-card.enemy {
      border-color: #7f1d1d;
    }
    .char-name {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 2px;
    }
    .hp-bar {
      height: 6px;
      background: #1f2937;
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 4px;
    }
    .hp-fill {
      height: 100%;
      background: #22c55e;
    }
    .stat-block {
      margin-bottom: 2px;
      line-height: 1.3;
    }
    .stat-label {
      color: #9ca3af;
    }
    .controls {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 12px;
    }
    select, input[type="number"] {
      background: #020617;
      border-radius: 6px;
      border: 1px solid #4b5563;
      color: #e5e7eb;
      padding: 4px 6px;
      font-size: 12px;
    }
    button {
      background: #1d4ed8;
      border: none;
      color: white;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    button.secondary {
      background: #374151;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .log {
      font-size: 11px;
      max-height: 380px;
      overflow-y: auto;
      background: #020617;
      border-radius: 6px;
      border: 1px solid #1f2937;
      padding: 6px;
      white-space: pre-line;
    }
    .log-line {
      margin-bottom: 2px;
    }
    .log-turn {
      color: #60a5fa;
      font-weight: 600;
      margin-top: 4px;
    }
    .mana-label {
      font-size: 12px;
      margin-bottom: 4px;
    }
    .mana-value {
      font-weight: 700;
    }
    .phase-label {
      font-size: 11px;
      color: #9ca3af;
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
<header>
  <div>
    <h1>Neeva â€” Core Combat Test</h1>
    <small>Solo combattimento & crit â€” niente deck, niente carte (per ora)</small>
  </div>
  <div style="font-size:12px;color:#9ca3af">
    Turno globale: <strong><span id="turnNumber">1</span></strong> â€”
    Lato attivo: <strong><span id="activeSideLabel">Player</span></strong>
  </div>
</header>

<main>
  <!-- COLONNA SINISTRA: Campo + Controlli -->
  <div class="column">
    <div class="section-title">Campo di Battaglia</div>
    <div class="phase-label">
      Fase: <span id="phaseLabel">-</span>
    </div>

    <div>
      <div style="font-size:12px;font-weight:600;margin-bottom:2px;">Il tuo team</div>
      <div class="team" id="playerTeam"></div>
    </div>

    <div>
      <div style="font-size:12px;font-weight:600;margin:6px 0 2px;">Team avversario</div>
      <div class="team" id="botTeam"></div>
    </div>

    <div style="margin-top:10px;" class="section-title">Controlli turno giocatore</div>
    <div class="controls">
      <label>
        Attaccante:
        <select id="selectAttacker"></select>
      </label>
      <label>
        Bersaglio:
        <select id="selectTarget"></select>
      </label>
      <label>
        VC:
        <input id="inputVC" type="number" step="0.05" min="0" value="1" style="width:60px;" />
      </label>
      <button id="btnAttack">Attacca</button>
      <button id="btnEndTurn" class="secondary">Passa turno</button>
    </div>
    <div style="font-size:11px;color:#9ca3af;margin-top:4px;">
      Regole critico usate:<br/>
      â€¢ Chance effettiva = CritChance attaccante âˆ’ CritResist difensore (min 0, max 100).<br/>
      â€¢ Se il tiro 1â€“100 â‰¤ chance effettiva â†’ <strong>colpo critico</strong>.<br/>
      â€¢ Danno base = ATK Ã— VC.<br/>
      â€¢ Critico: dannoCrit = base Ã— (CritDamage% âˆ’ CritDef%) / 100 (min 0), poi âˆ’DEF.<br/>
      â€¢ Non critico: danno = base âˆ’ DEF.
    </div>
  </div>

  <!-- COLONNA DESTRA: Log -->
  <div class="column">
    <div class="section-title">Log di combattimento</div>
    <div id="log" class="log"></div>
  </div>
</main>

<script>
  /****************************************************
   * STATO DI GIOCO BASE
   ****************************************************/

  const gameState = {
    globalTurn: 1,        // 1 = player, 2 = bot, 3 = player, ...
    currentSide: "player",// "player" | "bot"
    phase: "player",      // "player" | "bot" | "ended"
    playerTeam: [],
    botTeam: []
  };

  /****************************************************
   * MODELLI PERSONAGGI (STAT COMPLETE)
   ****************************************************/

  function createCharacter(id, name, side, stats) {
    return {
      id,
      name,
      side, // "player" | "bot"
      base: { ...stats },
      current: { ...stats },
      alive: true
    };
  }

  function initTeams() {
    gameState.playerTeam = [
      // ðŸŸ¦ BASIL â€” Tank Support
      createCharacter("basil", "Basil", "player", {
        lp: 980, lpMax: 980,
        atk: 63,
        def: 27,
        critChance: 60,    // %
        critDmg: 120,      // %
        critResist: 22,    // %
        critDef: 47        // %
      }),
      // ðŸŸ¥ GAEL â€” Bruiser Difensivo
      createCharacter("gael", "Gael", "player", {
        lp: 900, lpMax: 900,
        atk: 72,
        def: 11,
        critChance: 30,
        critDmg: 150,
        critResist: 10,
        critDef: 25
      }),
      // ðŸŸ© ZAGROK â€” Bruiser Offensivo
      createCharacter("zagrok", "Zagrok", "player", {
        lp: 830, lpMax: 830,
        atk: 68,
        def: 13,
        critChance: 30,
        critDmg: 150,
        critResist: 30,
        critDef: 20
      })
    ];

    gameState.botTeam = [
      // ðŸŸ« MORDEL â€” Tank Debuffer
      createCharacter("mordel", "Mordel", "bot", {
        lp: 1020, lpMax: 1020,
        atk: 60,
        def: 32,
        critChance: 25,
        critDmg: 150,
        critResist: 25,
        critDef: 33
      }),
      // ðŸŸª KIDDOU â€” Crit Support
      createCharacter("kiddou", "Kiddou", "bot", {
        lp: 820, lpMax: 820,
        atk: 58,
        def: 23,
        critChance: 40,
        critDmg: 160,
        critResist: 20,
        critDef: 26
      }),
      // ðŸ’œ RINDU â€” Bruiser Offensivo
      createCharacter("rindu", "Rindu", "bot", {
        lp: 860, lpMax: 860,
        atk: 78,
        def: 28,
        critChance: 28,
        critDmg: 150,
        critResist: 20,
        critDef: 22
      })
    ];
  }

  function getTeam(side) {
    return side === "player" ? gameState.playerTeam : gameState.botTeam;
  }

  function getOpposingTeam(side) {
    return side === "player" ? gameState.botTeam : gameState.playerTeam;
  }

  /****************************************************
   * LOG
   ****************************************************/

  const logEl = document.getElementById("log");

  function logLine(text, isTurnHeader = false) {
    const div = document.createElement("div");
    div.className = "log-line" + (isTurnHeader ? " log-turn" : "");
    div.textContent = text;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }

  /****************************************************
   * COMBATTIMENTO CON CRIT
   ****************************************************/

  /**
   * Esegue un attacco con VC e sistema critico.
   * Ritorna il danno finale inflitto ai LP (dopo DEF).
   */
  function attackWithCrit(source, target, vc) {
    if (!source.alive || !target.alive) return 0;
    if (vc < 0) vc = 0;

    const s = source.current;
    const t = target.current;

    const baseRaw = Math.round(s.atk * vc);

    // chance effettiva: CritChance attaccante - CritResist difensore
    let effChance = s.critChance - t.critResist;
    if (effChance < 0) effChance = 0;
    if (effChance > 100) effChance = 100;

    const roll = Math.floor(Math.random() * 100) + 1;
    const isCrit = roll <= effChance;

    let damageBeforeDef;
    let logDetails = `ATK ${s.atk} Ã— VC ${vc.toFixed(2)} = base ${baseRaw}. `;

    if (isCrit) {
      // critDamageEff = (CritDamage% - CritDef%) / 100, min 0
      let critEffPercent = s.critDmg - t.critDef;
      if (critEffPercent < 0) critEffPercent = 0;
      const critMultiplier = critEffPercent / 100;
      damageBeforeDef = Math.round(baseRaw * critMultiplier);
      logDetails += `(CRIT: (CritDmg ${s.critDmg}% âˆ’ CritDef ${t.critDef}%) = ${critEffPercent}%, ` +
                    `moltiplicatore ${critMultiplier.toFixed(2)} â†’ ${damageBeforeDef}). `;
    } else {
      damageBeforeDef = baseRaw;
      logDetails += `(non critico). `;
    }

    const damageAfterDef = Math.max(0, damageBeforeDef - t.def);
    logDetails += `âˆ’ DEF ${t.def} = danno finale ${damageAfterDef}.`;

    if (damageAfterDef <= 0) {
      logLine(`${source.name} attacca ${target.name}: nessun danno ai LP. ${logDetails}`);
      return 0;
    }

    const newLp = Math.max(0, t.lp - damageAfterDef);
    const lost = t.lp - newLp;
    t.lp = newLp;

    logLine(
      `${source.name} attacca ${target.name} ` +
      (isCrit ? `ðŸ’¥ CRITICO! ` : ``) +
      `e infligge ${lost} danni.`
    );
    logLine(`  Dettaglio: ${logDetails}`);

    if (t.lp <= 0) {
      target.alive = false;
      logLine(`${target.name} Ã¨ stato sconfitto!`);
    }

    return lost;
  }

  /****************************************************
   * TURNI
   ****************************************************/

  function startGame() {
    initTeams();
    gameState.globalTurn = 1;
    gameState.currentSide = "player";
    gameState.phase = "player";
    logEl.innerHTML = "";
    logLine("Inizio partita Neeva â€” test combattimento & crit.");
    logLine(`â€” TURNO ${gameState.globalTurn} (GIOCATORE) â€”`, true);
    updateUIPhase();
    render();
    updateSelectors();
  }

  function endPlayerTurn() {
    if (gameState.phase !== "player") return;
    gameState.phase = "bot";
    gameState.globalTurn += 1;
    gameState.currentSide = "bot";
    updateUIPhase();
    render();

    logLine("");
    logLine(`â€” TURNO ${gameState.globalTurn} (BOT) â€”`, true);

    botAction();

    if (checkEndGame()) return;

    // passa di nuovo al giocatore
    gameState.phase = "player";
    gameState.globalTurn += 1;
    gameState.currentSide = "player";
    logLine("");
    logLine(`â€” TURNO ${gameState.globalTurn} (GIOCATORE) â€”`, true);
    updateUIPhase();
    render();
    updateSelectors();
  }

  function botAction() {
    const botTeam = getTeam("bot").filter(c => c.alive);
    const playerTeam = getTeam("player").filter(c => c.alive);
    if (botTeam.length === 0 || playerTeam.length === 0) return;

    const attacker = botTeam[Math.floor(Math.random() * botTeam.length)];
    const target = playerTeam[Math.floor(Math.random() * playerTeam.length)];

    logLine(`${attacker.name} sceglie ${target.name} come bersaglio.`);
    attackWithCrit(attacker, target, 1.0); // VC fisso 1 per il bot
  }

  function checkEndGame() {
    const playerAlive = gameState.playerTeam.some(c => c.alive);
    const botAlive = gameState.botTeam.some(c => c.alive);

    if (!playerAlive || !botAlive) {
      logLine("");
      if (playerAlive && !botAlive) {
        logLine("ðŸŽ‰ HAI VINTO!", true);
      } else if (!playerAlive && botAlive) {
        logLine("ðŸ’€ HAI PERSO!", true);
      } else {
        logLine("âš–ï¸ PAREGGIO (tutti i PG sconfitti).", true);
      }
      gameState.phase = "ended";
      updateUIPhase();
      return true;
    }
    return false;
  }

  /****************************************************
   * UI
   ****************************************************/

  const turnNumberEl = document.getElementById("turnNumber");
  const activeSideLabelEl = document.getElementById("activeSideLabel");
  const phaseLabelEl = document.getElementById("phaseLabel");

  function updateUIPhase() {
    turnNumberEl.textContent = gameState.globalTurn;
    activeSideLabelEl.textContent =
      gameState.currentSide === "player" ? "Player" : "Bot";

    let txt = "-";
    if (gameState.phase === "player") txt = "Turno del Giocatore";
    else if (gameState.phase === "bot") txt = "Turno del Bot";
    else if (gameState.phase === "ended") txt = "Partita terminata";
    phaseLabelEl.textContent = txt;

    document.getElementById("btnAttack").disabled = (gameState.phase !== "player");
    document.getElementById("btnEndTurn").disabled = (gameState.phase !== "player");
  }

  function render() {
    renderTeam("playerTeam", gameState.playerTeam);
    renderTeam("botTeam", gameState.botTeam, true);
  }

  function renderTeam(containerId, team, isEnemy = false) {
    const container = document.getElementById(containerId);
    container.innerHTML = "";
    team.forEach(ch => {
      const c = ch.current;
      const card = document.createElement("div");
      card.className = "char-card" + (isEnemy ? " enemy" : "");

      const nameDiv = document.createElement("div");
      nameDiv.className = "char-name";
      nameDiv.textContent = ch.name + (ch.alive ? "" : " (KO)");
      card.appendChild(nameDiv);

      const hpBar = document.createElement("div");
      hpBar.className = "hp-bar";
      const hpFill = document.createElement("div");
      hpFill.className = "hp-fill";
      const ratio = c.lp / c.lpMax;
      hpFill.style.width = (Math.max(0, Math.min(1, ratio)) * 100) + "%";
      hpBar.appendChild(hpFill);
      card.appendChild(hpBar);

      const stat1 = document.createElement("div");
      stat1.className = "stat-block";
      stat1.innerHTML =
        `<span class="stat-label">LP:</span> ${c.lp}/${c.lpMax}<br>` +
        `<span class="stat-label">ATK:</span> ${c.atk} â€” ` +
        `<span class="stat-label">DEF:</span> ${c.def}`;
      card.appendChild(stat1);

      const stat2 = document.createElement("div");
      stat2.className = "stat-block";
      stat2.innerHTML =
        `<span class="stat-label">Crit%</span> ${c.critChance}% â€” ` +
        `<span class="stat-label">CritDmg:</span> ${c.critDmg}%<br>` +
        `<span class="stat-label">CritResist:</span> ${c.critResist}% â€” ` +
        `<span class="stat-label">CritDef:</span> ${c.critDef}%`;
      card.appendChild(stat2);

      container.appendChild(card);
    });
  }

  // Selettori attaccante/bersaglio
  const selectAttacker = document.getElementById("selectAttacker");
  const selectTarget = document.getElementById("selectTarget");
  const inputVC = document.getElementById("inputVC");

  function updateSelectors() {
    // attaccanti = solo team player vivi
    selectAttacker.innerHTML = "";
    getTeam("player").forEach(ch => {
      if (!ch.alive) return;
      const opt = document.createElement("option");
      opt.value = ch.id;
      opt.textContent = ch.name;
      selectAttacker.appendChild(opt);
    });

    // bersagli = solo bot vivi
    selectTarget.innerHTML = "";
    getTeam("bot").forEach(ch => {
      if (!ch.alive) return;
      const opt = document.createElement("option");
      opt.value = ch.id;
      opt.textContent = ch.name;
      selectTarget.appendChild(opt);
    });

    // se uno dei due Ã¨ vuoto, disattiva attacco
    const canAttack = selectAttacker.options.length > 0 && selectTarget.options.length > 0;
    document.getElementById("btnAttack").disabled = !canAttack || gameState.phase !== "player";
  }

  /****************************************************
   * EVENTI
   ****************************************************/

  document.getElementById("btnAttack").addEventListener("click", () => {
    if (gameState.phase !== "player") return;
    const attackerId = selectAttacker.value;
    const targetId = selectTarget.value;
    if (!attackerId || !targetId) {
      alert("Seleziona attaccante e bersaglio.");
      return;
    }
    const attacker = getTeam("player").find(c => c.id === attackerId);
    const target = getTeam("bot").find(c => c.id === targetId);
    if (!attacker || !target || !attacker.alive || !target.alive) {
      alert("Attaccante o bersaglio non valido.");
      return;
    }
    let vc = parseFloat(inputVC.value);
    if (isNaN(vc)) vc = 1;

    logLine(`Il giocatore dichiara attacco: ${attacker.name} â†’ ${target.name} (VC ${vc.toFixed(2)}).`);
    attackWithCrit(attacker, target, vc);
    render();
    updateSelectors();
    checkEndGame();
  });

  document.getElementById("btnEndTurn").addEventListener("click", () => {
    if (gameState.phase !== "player") return;
    endPlayerTurn();
  });

  /****************************************************
   * AVVIO
   ****************************************************/

  startGame();
</script>
</body>
</html>
