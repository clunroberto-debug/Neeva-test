<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Neeva Battle Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 8px 16px;
      background: #0f172a;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      font-size: 16px;
      margin: 0;
    }
    header .subtitle {
      font-size: 12px;
      color: #9ca3af;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 8px;
      gap: 8px;
    }

    .teams {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .team-col {
      background: #020617;
      border-radius: 12px;
      padding: 8px;
      border: 1px solid #1f2937;
    }

    .team-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    .character-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .char-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      border-radius: 10px;
      background: #020617;
      border: 1px solid #1e293b;
      font-size: 12px;
    }
    .char-main {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .char-name {
      font-weight: 600;
      font-size: 13px;
    }
    .char-hp {
      font-size: 11px;
    }
    .char-hp-bar {
      width: 100px;
      height: 6px;
      border-radius: 999px;
      background: #111827;
      overflow: hidden;
    }
    .char-hp-bar-inner {
      height: 100%;
      border-radius: 999px;
      background: #22c55e;
    }

    .char-stats {
      font-size: 10px;
      color: #9ca3af;
      text-align: right;
    }

    .status-dead .char-hp-bar-inner {
      width: 0 !important;
    }
    .status-dead {
      opacity: 0.4;
    }

    .turn-panel {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .turn-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }
    .badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #1e293b;
      color: #e5e7eb;
    }

    .cards-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      margin-top: 4px;
    }

    .card {
      border-radius: 10px;
      padding: 6px;
      border: 1px solid #1f2937;
      background: #020617;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 11px;
      min-height: 70px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .card:hover {
      border-color: #38bdf8;
    }
    .card.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .card.selected {
      border-color: #22c55e;
      box-shadow: 0 0 0 1px #22c55e55;
    }

    .card-title {
      font-weight: 600;
      font-size: 12px;
    }
    .card-meta {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #9ca3af;
    }
    .card-desc {
      font-size: 10px;
      color: #e5e7eb;
    }

    .log-panel {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: 140px;
    }
    .log-panel h2 {
      font-size: 12px;
      margin: 0;
    }
    .log-content {
      flex: 1;
      font-size: 10px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .log-line {
      margin-bottom: 2px;
    }
    .log-line.system {
      color: #9ca3af;
    }
    .log-line.player {
      color: #22c55e;
    }
    .log-line.enemy {
      color: #f97316;
    }

    .actions {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }
    button {
      font-family: inherit;
      font-size: 12px;
      border-radius: 999px;
      border: none;
      padding: 6px 10px;
      cursor: pointer;
      background: #22c55e;
      color: #020617;
      font-weight: 600;
    }
    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .target-hint {
      font-size: 11px;
      color: #f97316;
      margin-top: 2px;
    }
  </style>
</head>
<body>
<header>
  <div>
    <h1>Neeva Battle Test</h1>
    <div class="subtitle">Base tipo Seven Deadly Sins: Grand Cross</div>
  </div>
  <div class="subtitle" id="turn-counter">Turno: 1</div>
</header>

<main>
  <section class="teams">
    <div class="team-col">
      <div class="team-title">Squadra Giocatore</div>
      <div class="character-list" id="player-team"></div>
    </div>
    <div class="team-col">
      <div class="team-title">Squadra Nemico</div>
      <div class="character-list" id="enemy-team"></div>
    </div>
  </section>

  <section class="turn-panel">
    <div class="turn-info">
      <div>
        Turno di: <span id="active-side-label" class="badge">Giocatore</span>
      </div>
      <div class="badge" id="active-unit-label">—</div>
    </div>

    <div id="target-hint" class="target-hint" style="display:none;">
      Seleziona un bersaglio per la carta giocata.
    </div>

    <div class="cards-grid" id="cards-grid">
      <!-- carte abilità generate via JS -->
    </div>

    <div class="actions">
      <button id="end-turn-btn" class="secondary">Fine turno / Auto nemico</button>
      <button id="next-round-btn">Nuova mano carte</button>
    </div>
  </section>

  <section class="log-panel">
    <h2>Log battaglia</h2>
    <div class="log-content" id="log"></div>
  </section>
</main>

<script>
  /********************************************
   * MODELLO DATI
   ********************************************/
  class Character {
    constructor(opts) {
      this.id = opts.id;
      this.name = opts.name;
      this.maxHP = opts.maxHP;
      this.hp = opts.maxHP;
      this.atk = opts.atk;
      this.def = opts.def;
      this.critChance = opts.critChance;   // in %
      this.critResist = opts.critResist;   // in %
      this.critDamage = opts.critDamage;   // valore base danno critico
      this.critDef = opts.critDef;         // riduzione del danno critico
      this.speed = opts.speed;
      this.side = opts.side;               // "player" o "enemy"
      this.skills = opts.skills || [];
    }

    get isDead() {
      return this.hp <= 0;
    }

    receiveDamage(amount) {
      this.hp = Math.max(0, this.hp - amount);
    }

    heal(amount) {
      this.hp = Math.min(this.maxHP, this.hp + amount);
    }
  }

  class Skill {
    constructor(opts) {
      this.id = opts.id;
      this.name = opts.name;
      this.description = opts.description;
      this.type = opts.type;    // "single" o "aoe"
      this.multiplier = opts.multiplier; // moltiplicatore base su ATK
      this.speedMod = opts.speedMod || 0;
      this.ownerId = opts.ownerId;
      this.source = opts.source; // "player" o "enemy"
    }
  }

  /********************************************
   * UTILS
   ********************************************/
  function log(msg, type = "system") {
    const logEl = document.getElementById("log");
    const line = document.createElement("div");
    line.className = "log-line " + type;
    line.textContent = msg;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Formula critico (come da tue regole di Niva):
  // Se (CritChance - CritResist) > 0 -> tiro d100
  // Se il tiro <= differenza => colpo critico
  // Danno critico = (CritDamage - CritDef)
  // Danno normale = (ATK - DEF)
  function calculateHit(attacker, defender, skillMultiplier) {
    // 1) ATTACCO BASE
    const baseAtk = attacker.atk * skillMultiplier;

    // 2) controllo critico
    const diff = attacker.critChance - defender.critResist;
    let isCrit = false;
    let rawDamage;
    if (diff > 0) {
      const roll = randomInt(1, 100);
      if (roll <= diff) {
        isCrit = true;
        rawDamage = (attacker.critDamage - defender.critDef);
      } else {
        rawDamage = (baseAtk - defender.def);
      }
    } else {
      // niente crit possibile
      rawDamage = (baseAtk - defender.def);
    }

    // minimo 0
    const damage = Math.max(0, Math.floor(rawDamage));
    return { damage, isCrit };
  }

  /********************************************
   * SETUP SQUADRE
   ********************************************/
  const playerTeam = [
    new Character({
      id: "p1",
      name: "Lariat",
      maxHP: 240,
      atk: 70,
      def: 35,
      critChance: 25,
      critResist: 10,
      critDamage: 120,
      critDef: 20,
      speed: 110,
      side: "player"
    }),
    new Character({
      id: "p2",
      name: "Dionere",
      maxHP: 220,
      atk: 80,
      def: 30,
      critChance: 30,
      critResist: 10,
      critDamage: 130,
      critDef: 15,
      speed: 100,
      side: "player"
    }),
    new Character({
      id: "p3",
      name: "Zelpa",
      maxHP: 260,
      atk: 60,
      def: 40,
      critChance: 20,
      critResist: 15,
      critDamage: 110,
      critDef: 25,
      speed: 90,
      side: "player"
    })
  ];

  const enemyTeam = [
    new Character({
      id: "e1",
      name: "Nemico A",
      maxHP: 230,
      atk: 65,
      def: 30,
      critChance: 20,
      critResist: 15,
      critDamage: 115,
      critDef: 20,
      speed: 105,
      side: "enemy"
    }),
    new Character({
      id: "e2",
      name: "Nemico B",
      maxHP: 250,
      atk: 60,
      def: 35,
      critChance: 18,
      critResist: 12,
      critDamage: 110,
      critDef: 18,
      speed: 95,
      side: "enemy"
    }),
    new Character({
      id: "e3",
      name: "Nemico C",
      maxHP: 240,
      atk: 70,
      def: 32,
      critChance: 22,
      critResist: 14,
      critDamage: 120,
      critDef: 22,
      speed: 98,
      side: "enemy"
    })
  ];

  // Associo 3 skill base a ogni personaggio (stile 3 carte fisse)
  function createDefaultSkillsForTeam(team) {
    const skills = [];
    for (const unit of team) {
      skills.push(
        new Skill({
          id: unit.id + "_s1",
          name: "Colpo Rapido",
          description: "Attacco singolo x1.0 ATK.",
          type: "single",
          multiplier: 1.0,
          ownerId: unit.id,
          source: unit.side
        }),
        new Skill({
          id: unit.id + "_s2",
          name: "Assalto Potente",
          description: "Attacco singolo x1.4 ATK.",
          type: "single",
          multiplier: 1.4,
          ownerId: unit.id,
          source: unit.side
        }),
        new Skill({
          id: unit.id + "_s3",
          name: "Onda d'Impatto",
          description: "Attacco AoE x0.8 ATK.",
          type: "aoe",
          multiplier: 0.8,
          ownerId: unit.id,
          source: unit.side
        })
      );
    }
    return skills;
  }

  const playerSkillsPool = createDefaultSkillsForTeam(playerTeam);
  const enemySkillsPool  = createDefaultSkillsForTeam(enemyTeam);

  /********************************************
   * STATO BATTAGLIA
   ********************************************/
  let turnNumber = 1;
  let activeSide = "player"; // "player" o "enemy"
  let activeUnit = null;     // Character
  let currentHand = [];      // carte visibili per il giocatore
  let selectedCardId = null;
  let waitingForTarget = false;

  /********************************************
   * RENDER UI
   ********************************************/
  function renderTeams() {
    const pContainer = document.getElementById("player-team");
    const eContainer = document.getElementById("enemy-team");
    pContainer.innerHTML = "";
    eContainer.innerHTML = "";

    function renderChar(char, container) {
      const wrapper = document.createElement("div");
      wrapper.className = "char-card" + (char.isDead ? " status-dead" : "");

      wrapper.dataset.charId = char.id;
      wrapper.dataset.side = char.side;

      const main = document.createElement("div");
      main.className = "char-main";

      const nameEl = document.createElement("div");
      nameEl.className = "char-name";
      nameEl.textContent = char.name;
      main.appendChild(nameEl);

      const hpText = document.createElement("div");
      hpText.className = "char-hp";
      hpText.textContent = `HP: ${char.hp} / ${char.maxHP}`;
      main.appendChild(hpText);

      const hpBar = document.createElement("div");
      hpBar.className = "char-hp-bar";
      const hpInner = document.createElement("div");
      hpInner.className = "char-hp-bar-inner";
      const perc = (char.hp / char.maxHP) * 100;
      hpInner.style.width = char.isDead ? "0%" : `${perc}%`;
      hpBar.appendChild(hpInner);
      main.appendChild(hpBar);

      const stats = document.createElement("div");
      stats.className = "char-stats";
      stats.innerHTML =
        `ATK ${char.atk} | DEF ${char.def}<br>` +
        `CR% ${char.critChance} | CRR ${char.critResist}`;

      wrapper.appendChild(main);
      wrapper.appendChild(stats);

      // Se sto aspettando un bersaglio e questo è un nemico vivo, permetto il click
      if (waitingForTarget && !char.isDead && char.side === (activeSide === "player" ? "enemy" : "player")) {
        wrapper.style.cursor = "pointer";
        wrapper.addEventListener("click", () => {
          onTargetSelected(char);
        });
      }

      container.appendChild(wrapper);
    }

    for (const c of playerTeam) renderChar(c, pContainer);
    for (const c of enemyTeam) renderChar(c, eContainer);
  }

  function renderTurnInfo() {
    const label = document.getElementById("active-side-label");
    const activeUnitLabel = document.getElementById("active-unit-label");
    const turnCounter = document.getElementById("turn-counter");

    label.textContent = activeSide === "player" ? "Giocatore" : "Nemico";
    label.style.background = activeSide === "player" ? "#22c55e22" : "#f9731622";
    activeUnitLabel.textContent = activeUnit ? activeUnit.name : "—";
    turnCounter.textContent = "Turno: " + turnNumber;
  }

  function renderCards() {
    const grid = document.getElementById("cards-grid");
    grid.innerHTML = "";

    for (const card of currentHand) {
      const div = document.createElement("div");
      div.className = "card";
      div.dataset.cardId = card.id;

      if (activeSide !== "player" || !activeUnit || activeUnit.id !== card.ownerId) {
        div.classList.add("disabled");
      }

      if (selectedCardId === card.id) {
        div.classList.add("selected");
      }

      const title = document.createElement("div");
      title.className = "card-title";
      title.textContent = card.name;
      div.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "card-meta";
      meta.innerHTML = `<span>${card.type.toUpperCase()}</span><span>x${card.multiplier.toFixed(1)} ATK</span>`;
      div.appendChild(meta);

      const desc = document.createElement("div");
      desc.className = "card-desc";
      desc.textContent = card.description;
      div.appendChild(desc);

      if (!div.classList.contains("disabled")) {
        div.addEventListener("click", () => onCardClicked(card));
      }

      grid.appendChild(div);
    }
  }

  function updateUI() {
    renderTeams();
    renderTurnInfo();
    renderCards();
  }

  /********************************************
   * LOGICA TURNO
   ********************************************/
  function getAlive(team) {
    return team.filter(c => !c.isDead);
  }

  function checkBattleEnd() {
    const playerAlive = getAlive(playerTeam).length;
    const enemyAlive = getAlive(enemyTeam).length;
    if (playerAlive === 0 || enemyAlive === 0) {
      const winner = playerAlive > 0 ? "Giocatore" : "Nemico";
      log(`La battaglia è finita! Vince: ${winner}`, "system");
      document.getElementById("end-turn-btn").disabled = true;
      document.getElementById("next-round-btn").disabled = true;
      return true;
    }
    return false;
  }

  function startNewRound() {
    // In una versione avanzata potresti ordinare la turn order per Speed.
    // Qui scegliamo un'unità viva a caso per il giocatore come "attivo".
    const alivePlayer = getAlive(playerTeam);
    if (alivePlayer.length === 0 || checkBattleEnd()) return;

    activeSide = "player";
    activeUnit = alivePlayer[randomInt(0, alivePlayer.length - 1)];

    // pesco 7 carte random dalla pool del giocatore
    currentHand = [];
    const pool = playerSkillsPool.filter(s => !getCharById(s.ownerId).isDead);
    for (let i = 0; i < 7 && pool.length > 0; i++) {
      const idx = randomInt(0, pool.length - 1);
      currentHand.push(pool[idx]);
    }

    selectedCardId = null;
    waitingForTarget = false;
    document.getElementById("target-hint").style.display = "none";
    log(`Nuova mano di carte per il giocatore (unità attiva: ${activeUnit.name}).`, "system");
    updateUI();
  }

  function onCardClicked(card) {
    if (selectedCardId === card.id) {
      // deselezione
      selectedCardId = null;
      waitingForTarget = false;
      document.getElementById("target-hint").style.display = "none";
    } else {
      selectedCardId = card.id;
      if (card.type === "single") {
        waitingForTarget = true;
        document.getElementById("target-hint").style.display = "block";
      } else {
        // AoE: nessun target da selezionare
        waitingForTarget = false;
        document.getElementById("target-hint").style.display = "none";
        playCardAoE(card);
      }
    }
    updateUI();
  }

  function onTargetSelected(targetChar) {
    const card = currentHand.find(c => c.id === selectedCardId);
    if (!card) return;
    playCardSingle(card, targetChar);
  }

  function getCharById(id) {
    return playerTeam.concat(enemyTeam).find(c => c.id === id);
  }

  function playCardSingle(card, target) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead) return;

    const { damage, isCrit } = calculateHit(caster, target, card.multiplier);
    target.receiveDamage(damage);

    log(
      `${caster.name} usa ${card.name} su ${target.name} e infligge ${damage} danni` +
      (isCrit ? " (CRITICO!)" : "") +
      `. HP rimanenti di ${target.name}: ${target.hp}/${target.maxHP}`,
      caster.side === "player" ? "player" : "enemy"
    );

    if (target.isDead) {
      log(`${target.name} viene sconfitto!`, "system");
    }

    selectedCardId = null;
    waitingForTarget = false;
    document.getElementById("target-hint").style.display = "none";
    updateUI();

    if (!checkBattleEnd()) {
      enemyAutoTurn();
    }
  }

  function playCardAoE(card) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead) return;
    const enemies = caster.side === "player" ? getAlive(enemyTeam) : getAlive(playerTeam);
    if (enemies.length === 0) return;

    log(`${caster.name} usa ${card.name} (AoE)`, caster.side === "player" ? "player" : "enemy");
    for (const enemy of enemies) {
      const { damage, isCrit } = calculateHit(caster, enemy, card.multiplier);
      enemy.receiveDamage(damage);
      log(
        ` → ${enemy.name} subisce ${damage} danni` + (isCrit ? " (CRITICO!)" : "") +
        ` [${enemy.hp}/${enemy.maxHP}]`,
        caster.side === "player" ? "player" : "enemy"
      );
      if (enemy.isDead) {
        log(`${enemy.name} viene sconfitto!`, "system");
      }
    }

    updateUI();

    if (!checkBattleEnd()) {
      enemyAutoTurn();
    }
  }

  function enemyAutoTurn() {
    if (checkBattleEnd()) return;
    activeSide = "enemy";

    const aliveEnemy = getAlive(enemyTeam);
    if (aliveEnemy.length === 0) return;
    activeUnit = aliveEnemy[randomInt(0, aliveEnemy.length - 1)];

    log(`Turno del nemico (unità attiva: ${activeUnit.name})`, "enemy");

    // il nemico sceglie una skill random e un bersaglio random
    const enemyCards = enemySkillsPool.filter(s => s.ownerId === activeUnit.id);
    const skill = enemyCards[randomInt(0, enemyCards.length - 1)];

    if (skill.type === "single") {
      const targets = getAlive(playerTeam);
      if (targets.length === 0) return;
      const target = targets[randomInt(0, targets.length - 1)];
      playEnemySingle(skill, target);
    } else {
      playEnemyAoE(skill);
    }
  }

  function playEnemySingle(card, target) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead) return;

    const { damage, isCrit } = calculateHit(caster, target, card.multiplier);
    target.receiveDamage(damage);

    log(
      `${caster.name} (nemico) usa ${card.name} su ${target.name} e infligge ${damage} danni` +
      (isCrit ? " (CRITICO!)" : "") +
      `. HP rimanenti di ${target.name}: ${target.hp}/${target.maxHP}`,
      "enemy"
    );

    if (target.isDead) {
      log(`${target.name} viene sconfitto!`, "system");
    }

    updateUI();
    if (!checkBattleEnd()) {
      // finito turno nemico, nuovo round giocatore
      turnNumber++;
      startNewRound();
    }
  }

  function playEnemyAoE(card) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead) return;
    const enemies = getAlive(playerTeam);
    if (enemies.length === 0) return;

    log(`${caster.name} (nemico) usa ${card.name} (AoE)`, "enemy");
    for (const enemy of enemies) {
      const { damage, isCrit } = calculateHit(caster, enemy, card.multiplier);
      enemy.receiveDamage(damage);
      log(
        ` → ${enemy.name} subisce ${damage} danni` + (isCrit ? " (CRITICO!)" : "") +
        ` [${enemy.hp}/${enemy.maxHP}]`,
        "enemy"
      );
      if (enemy.isDead) {
        log(`${enemy.name} viene sconfitto!`, "system");
      }
    }

    updateUI();
    if (!checkBattleEnd()) {
      turnNumber++;
      startNewRound();
    }
  }

  /********************************************
   * EVENTI UI
   ********************************************/
  document.getElementById("end-turn-btn").addEventListener("click", () => {
    // forza il turno nemico (anche se non hai giocato nessuna carta)
    if (activeSide === "player" && !checkBattleEnd()) {
      enemyAutoTurn();
    }
  });

  document.getElementById("next-round-btn").addEventListener("click", () => {
    if (activeSide === "player") {
      turnNumber++;
      startNewRound();
    }
  });

  /********************************************
   * INIZIALIZZAZIONE
   ********************************************/
  function initBattle() {
    log("Inizio battaglia 3 vs 3.", "system");
    startNewRound();
    updateUI();
  }

  initBattle();
</script>
</body>
</html>
