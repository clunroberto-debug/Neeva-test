<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Test Combattimento Crit - Neeva</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 8px 16px;
      background: #0f172a;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 8px;
    }
    .teams {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .team-col {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 8px;
    }
    .team-title {
      font-size: 11px;
      text-transform: uppercase;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .character-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .char-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid #1e293b;
      background: #020617;
      font-size: 11px;
    }
    .char-card.dead { opacity: 0.4; }
    .char-main {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .char-name {
      font-weight: 600;
      font-size: 12px;
    }
    .char-hp {
      font-size: 11px;
    }
    .char-hp-bar {
      width: 100px;
      height: 6px;
      border-radius: 999px;
      background: #111827;
      overflow: hidden;
    }
    .char-hp-bar-inner {
      height: 100%;
      border-radius: 999px;
      background: #22c55e;
    }
    .char-stats {
      font-size: 10px;
      color: #9ca3af;
      text-align: right;
    }

    .turn-panel {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .turn-info {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
    }
    .badge {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 10px;
      background: #1e293b;
    }

    .cards-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      margin-top: 4px;
    }
    .card {
      border-radius: 10px;
      border: 1px solid #1f2937;
      background: #020617;
      padding: 6px;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      cursor: pointer;
    }
    .card.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .card.selected {
      border-color: #22c55e;
      box-shadow: 0 0 0 1px #22c55e55;
    }
    .card-title {
      font-weight: 600;
      font-size: 12px;
    }
    .card-meta {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #9ca3af;
    }
    .card-desc {
      font-size: 10px;
    }

    .target-hint {
      font-size: 11px;
      color: #f97316;
    }

    .actions {
      display: flex;
      gap: 6px;
      margin-top: 4px;
    }
    button {
      font-family: inherit;
      font-size: 12px;
      border-radius: 999px;
      border: none;
      padding: 6px 10px;
      cursor: pointer;
      background: #22c55e;
      color: #020617;
      font-weight: 600;
    }
    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .log-panel {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      height: 150px;
    }
    .log-panel h2 {
      font-size: 12px;
      margin: 0;
    }
    .log-content {
      flex: 1;
      font-size: 10px;
      overflow-y: auto;
    }
    .log-line { margin-bottom: 2px; }
    .log-line.player { color: #22c55e; }
    .log-line.enemy { color: #f97316; }
    .log-line.system { color: #9ca3af; }
  </style>
</head>
<body>
<header>
  <div>
    <strong>Test Combattimento (Crit / VC)</strong>
  </div>
  <div id="turn-counter">Turno: 1</div>
</header>

<main>
  <section class="teams">
    <div class="team-col">
      <div class="team-title">Squadra Giocatore</div>
      <div id="player-team" class="character-list"></div>
    </div>
    <div class="team-col">
      <div class="team-title">Squadra Nemico</div>
      <div id="enemy-team" class="character-list"></div>
    </div>
  </section>

  <section class="turn-panel">
    <div class="turn-info">
      <div>Turno di: <span id="active-side" class="badge">Giocatore</span></div>
      <div>Unità attiva: <span id="active-unit" class="badge">—</span></div>
    </div>

    <div id="target-hint" class="target-hint" style="display:none;">
      Seleziona il bersaglio.
    </div>

    <div id="cards-grid" class="cards-grid"></div>

    <div class="actions">
      <button id="end-turn-btn" class="secondary">Fine turno / Auto nemico</button>
      <button id="new-hand-btn">Nuova mano</button>
    </div>
  </section>

  <section class="log-panel">
    <h2>Log</h2>
    <div id="log" class="log-content"></div>
  </section>
</main>

<script>
  /*********************
   * Utils
   *********************/
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function log(msg, type = "system") {
    const logEl = document.getElementById("log");
    const line = document.createElement("div");
    line.className = "log-line " + type;
    line.textContent = msg;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  /*********************
   * Modello dati
   *********************/
  class Character {
    constructor(opts) {
      this.id = opts.id;
      this.name = opts.name;
      this.maxHP = opts.maxHP;
      this.hp = opts.maxHP;

      this.ATK = opts.ATK;
      this.DEF = opts.DEF;

      this.CRIT_CHANCE = opts.CRIT_CHANCE;   // %
      this.CRIT_RESIST = opts.CRIT_RESIST;   // %
      this.CRIT_DMG = opts.CRIT_DMG;         // %
      this.CRIT_DEF = opts.CRIT_DEF;         // valore fisso

      this.side = opts.side; // "player" o "enemy"
    }

    get isDead() {
      return this.hp <= 0;
    }

    receiveDamage(amount) {
      this.hp = Math.max(0, this.hp - amount);
    }
  }

  class Card {
    constructor(opts) {
      this.id = opts.id;
      this.name = opts.name;
      this.description = opts.description;
      this.type = opts.type;          // "single" o "aoe"
      this.VC = opts.VC;              // in %
      this.ownerId = opts.ownerId;
      this.source = opts.source;      // "player" o "enemy"
    }
  }

  /*********************
   * Formule di danno
   *********************/
  // RITORNA ANCHE TUTTI I DETTAGLI DEL CALCOLO
  function calculateDamage(att, def, VC) {
    const vcFactor = VC / 100;
    const atkCard = att.ATK * vcFactor;  // ATK_carta

    let critChanceEff = att.CRIT_CHANCE - def.CRIT_RESIST;
    if (critChanceEff < 0) critChanceEff = 0;
    if (critChanceEff > 100) critChanceEff = 100;

    let isCrit = false;
    let roll = null;

    if (critChanceEff > 0) {
      roll = randomInt(1, 100);
      if (roll <= critChanceEff) {
        isCrit = true;
      }
    }

    if (!isCrit) {
      const rawNormal = atkCard - def.DEF;
      const dmg = Math.max(0, Math.round(rawNormal));
      return {
        damage: dmg,
        isCrit: false,
        roll,
        critChanceEff,
        atkCard,
        rawNormal,
        critRawAtt: null,
        critAfterDef: null
      };
    }

    const critFactor = att.CRIT_DMG / 100;
    const critRawAtt = atkCard * critFactor;
    const critAfterDef = critRawAtt - def.CRIT_DEF;
    const dmg = Math.max(0, Math.round(critAfterDef));

    return {
      damage: dmg,
      isCrit: true,
      roll,
      critChanceEff,
      atkCard,
      rawNormal: null,
      critRawAtt,
      critAfterDef
    };
  }

  /*********************
   * Setup squadre
   *********************/
  const playerTeam = [
    new Character({
      id: "p1",
      name: "Lariat",
      maxHP: 250,
      ATK: 80,
      DEF: 30,
      CRIT_CHANCE: 25,
      CRIT_RESIST: 10,
      CRIT_DMG: 150,  // 150% dell'ATK_carta in caso di crit
      CRIT_DEF: 20,
      side: "player"
    }),
    new Character({
      id: "p2",
      name: "Dionere",
      maxHP: 230,
      ATK: 85,
      DEF: 28,
      CRIT_CHANCE: 30,
      CRIT_RESIST: 12,
      CRIT_DMG: 160,
      CRIT_DEF: 18,
      side: "player"
    }),
    new Character({
      id: "p3",
      name: "Zelpa",
      maxHP: 260,
      ATK: 70,
      DEF: 35,
      CRIT_CHANCE: 20,
      CRIT_RESIST: 15,
      CRIT_DMG: 140,
      CRIT_DEF: 22,
      side: "player"
    })
  ];

  const enemyTeam = [
    new Character({
      id: "e1",
      name: "Nemico A",
      maxHP: 240,
      ATK: 75,
      DEF: 30,
      CRIT_CHANCE: 22,
      CRIT_RESIST: 14,
      CRIT_DMG: 145,
      CRIT_DEF: 18,
      side: "enemy"
    }),
    new Character({
      id: "e2",
      name: "Nemico B",
      maxHP: 255,
      ATK: 78,
      DEF: 32,
      CRIT_CHANCE: 24,
      CRIT_RESIST: 12,
      CRIT_DMG: 150,
      CRIT_DEF: 20,
      side: "enemy"
    }),
    new Character({
      id: "e3",
      name: "Nemico C",
      maxHP: 235,
      ATK: 82,
      DEF: 27,
      CRIT_CHANCE: 26,
      CRIT_RESIST: 13,
      CRIT_DMG: 155,
      CRIT_DEF: 19,
      side: "enemy"
    })
  ];

  function createCardsForTeam(team, side) {
    const cards = [];
    for (const unit of team) {
      cards.push(
        new Card({
          id: unit.id + "_c1",
          name: "Colpo Secco",
          description: "120% ATK a un bersaglio.",
          type: "single",
          VC: 120,
          ownerId: unit.id,
          source: side
        }),
        new Card({
          id: unit.id + "_c2",
          name: "Assalto Feroce",
          description: "160% ATK a un bersaglio.",
          type: "single",
          VC: 160,
          ownerId: unit.id,
          source: side
        }),
        new Card({
          id: unit.id + "_c3",
          name: "Onda d'Impatto",
          description: "90% ATK a tutti i nemici.",
          type: "aoe",
          VC: 90,
          ownerId: unit.id,
          source: side
        })
      );
    }
    return cards;
  }

  const playerCardsPool = createCardsForTeam(playerTeam, "player");
  const enemyCardsPool  = createCardsForTeam(enemyTeam, "enemy");

  /*********************
   * Stato battaglia
   *********************/
  let turnNumber = 1;
  let activeSide = "player";
  let activeUnit = null;
  let currentHand = [];
  let selectedCardId = null;
  let waitingForTarget = false;

  /*********************
   * Render UI
   *********************/
  function renderTeams() {
    const pC = document.getElementById("player-team");
    const eC = document.getElementById("enemy-team");
    pC.innerHTML = "";
    eC.innerHTML = "";

    function renderChar(char, container) {
      const card = document.createElement("div");
      card.className = "char-card" + (char.isDead ? " dead" : "");
      card.dataset.charId = char.id;
      card.dataset.side = char.side;

      const main = document.createElement("div");
      main.className = "char-main";

      const nameEl = document.createElement("div");
      nameEl.className = "char-name";
      nameEl.textContent = char.name;
      main.appendChild(nameEl);

      const hpText = document.createElement("div");
      hpText.className = "char-hp";
      hpText.textContent = `HP: ${char.hp} / ${char.maxHP}`;
      main.appendChild(hpText);

      const hpBar = document.createElement("div");
      hpBar.className = "char-hp-bar";
      const hpInner = document.createElement("div");
      hpInner.className = "char-hp-bar-inner";
      const perc = (char.hp / char.maxHP) * 100;
      hpInner.style.width = char.isDead ? "0%" : `${perc}%`;
      hpBar.appendChild(hpInner);
      main.appendChild(hpBar);

      const stats = document.createElement("div");
      stats.className = "char-stats";
      stats.innerHTML =
        `ATK ${char.ATK} | DEF ${char.DEF}<br>` +
        `C% ${char.CRIT_CHANCE} | CR ${char.CRIT_RESIST}<br>` +
        `CD% ${char.CRIT_DMG} | CDEF ${char.CRIT_DEF}`;

      card.appendChild(main);
      card.appendChild(stats);

      if (waitingForTarget &&
          !char.isDead &&
          char.side !== activeSide) {
        card.style.cursor = "pointer";
        card.addEventListener("click", () => {
          onTargetSelected(char);
        });
      }

      container.appendChild(card);
    }

    for (const c of playerTeam) renderChar(c, pC);
    for (const c of enemyTeam) renderChar(c, eC);
  }

  function renderTurnInfo() {
    document.getElementById("turn-counter").textContent = "Turno: " + turnNumber;
    const sideEl = document.getElementById("active-side");
    sideEl.textContent = activeSide === "player" ? "Giocatore" : "Nemico";
    sideEl.style.background = activeSide === "player" ? "#22c55e22" : "#f9731622";
    document.getElementById("active-unit").textContent = activeUnit ? activeUnit.name : "—";
  }

  function renderCards() {
    const grid = document.getElementById("cards-grid");
    grid.innerHTML = "";

    for (const card of currentHand) {
      const div = document.createElement("div");
      div.className = "card";
      div.dataset.cardId = card.id;

      if (activeSide !== "player" || !activeUnit || activeUnit.id !== card.ownerId || activeUnit.isDead) {
        div.classList.add("disabled");
      }
      if (selectedCardId === card.id) {
        div.classList.add("selected");
      }

      const title = document.createElement("div");
      title.className = "card-title";
      title.textContent = card.name;
      div.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "card-meta";
      meta.innerHTML =
        `<span>${card.type.toUpperCase()}</span><span>${card.VC}% ATK</span>`;
      div.appendChild(meta);

      const desc = document.createElement("div");
      desc.className = "card-desc";
      desc.textContent = card.description;
      div.appendChild(desc);

      if (!div.classList.contains("disabled")) {
        div.addEventListener("click", () => onCardClicked(card));
      }

      grid.appendChild(div);
    }
  }

  function updateUI() {
    renderTeams();
    renderTurnInfo();
    renderCards();
  }

  /*********************
   * Logica turno
   *********************/
  function getAlive(team) {
    return team.filter(c => !c.isDead);
  }

  function checkEnd() {
    const pAlive = getAlive(playerTeam).length;
    const eAlive = getAlive(enemyTeam).length;
    if (pAlive === 0 || eAlive === 0) {
      const winner = pAlive > 0 ? "Giocatore" : "Nemico";
      log(`Battaglia finita! Vince: ${winner}`, "system");
      document.getElementById("end-turn-btn").disabled = true;
      document.getElementById("new-hand-btn").disabled = true;
      return true;
    }
    return false;
  }

  function startNewPlayerTurn() {
    const alive = getAlive(playerTeam);
    if (alive.length === 0 || checkEnd()) return;
    activeSide = "player";
    activeUnit = alive[randomInt(0, alive.length - 1)];
    const pool = playerCardsPool.filter(c => !getCharById(c.ownerId).isDead);
    currentHand = [];
    for (let i = 0; i < 5 && pool.length > 0; i++) {
      const idx = randomInt(0, pool.length - 1);
      currentHand.push(pool[idx]);
    }
    selectedCardId = null;
    waitingForTarget = false;
    document.getElementById("target-hint").style.display = "none";
    log(`Nuovo turno giocatore. Unità attiva: ${activeUnit.name}`, "system");
    updateUI();
  }

  function getCharById(id) {
    return [...playerTeam, ...enemyTeam].find(c => c.id === id);
  }

  function onCardClicked(card) {
    if (selectedCardId === card.id) {
      selectedCardId = null;
      waitingForTarget = false;
      document.getElementById("target-hint").style.display = "none";
      updateUI();
      return;
    }
    selectedCardId = card.id;
    if (card.type === "single") {
      waitingForTarget = true;
      document.getElementById("target-hint").style.display = "block";
    } else {
      waitingForTarget = false;
      document.getElementById("target-hint").style.display = "none";
      playCardAoE(card);
    }
    updateUI();
  }

  function onTargetSelected(target) {
    const card = currentHand.find(c => c.id === selectedCardId);
    if (!card) return;
    playCardSingle(card, target);
  }

  function logCritDetails(caster, target, card, res, sideType) {
    const who = sideType === "player" ? "Giocatore" : "Nemico";
    // riga riassunto attacco
    log(
      `${caster.name} (${who}) usa ${card.name} su ${target.name}: ` +
      `${res.damage} danni` + (res.isCrit ? " [CRITICO]" : " [normale]"),
      sideType
    );
    // dettagli del tiro critico
    if (res.critChanceEff !== null && res.critChanceEff !== undefined) {
      const rollText = res.roll === null ? "n/a" : res.roll;
      log(
        `  CritChanceEff = ${res.critChanceEff}%, tiro d100 = ${rollText}` +
        (res.isCrit ? " → CRIT" : " → NO CRIT"),
        "system"
      );
    }
    // dettagli atk carta e formula
    log(`  ATK_carta = ATK (${caster.ATK}) x VC (${card.VC}%) = ${res.atkCard.toFixed(2)}`, "system");

    if (!res.isCrit) {
      log(
        `  Danno normale: ATK_carta (${res.atkCard.toFixed(2)}) - DEF (${target.DEF}) = ` +
        `${res.rawNormal.toFixed(2)} → ${res.damage}`,
        "system"
      );
    } else {
      log(
        `  Danno crit: ATK_carta (${res.atkCard.toFixed(2)}) x CRIT_DMG (${caster.CRIT_DMG}%) = ` +
        `${res.critRawAtt.toFixed(2)}`,
        "system"
      );
      log(
        `  Applico CRIT_DEF (${target.CRIT_DEF}): ${res.critRawAtt.toFixed(2)} - ${target.CRIT_DEF} = ` +
        `${res.critAfterDef.toFixed(2)} → ${res.damage}`,
        "system"
      );
    }

    log(`  HP ${target.name}: ${target.hp} / ${target.maxHP}`, "system");
  }

  function playCardSingle(card, target) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead || target.isDead) return;

    const res = calculateDamage(caster, target, card.VC);
    target.receiveDamage(res.damage);

    logCritDetails(caster, target, card, res, caster.side);

    if (target.isDead) {
      log(`${target.name} è stato sconfitto.`, "system");
    }

    selectedCardId = null;
    waitingForTarget = false;
    document.getElementById("target-hint").style.display = "none";
    updateUI();

    if (!checkEnd()) {
      enemyTurnAuto();
    }
  }

  function playCardAoE(card) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead) return;
    const enemies = caster.side === "player" ? getAlive(enemyTeam) : getAlive(playerTeam);
    if (enemies.length === 0) return;

    log(`${caster.name} usa ${card.name} (AoE)`, caster.side === "player" ? "player" : "enemy");

    for (const target of enemies) {
      const res = calculateDamage(caster, target, card.VC);
      target.receiveDamage(res.damage);

      logCritDetails(caster, target, card, res, caster.side);

      if (target.isDead) {
        log(`${target.name} è stato sconfitto.`, "system");
      }
    }

    updateUI();
    if (!checkEnd()) {
      enemyTurnAuto();
    }
  }

  function enemyTurnAuto() {
    if (checkEnd()) return;
    activeSide = "enemy";
    const alive = getAlive(enemyTeam);
    if (alive.length === 0) return;
    activeUnit = alive[randomInt(0, alive.length - 1)];

    log(`Turno del nemico. Unità attiva: ${activeUnit.name}`, "enemy");

    const cards = enemyCardsPool.filter(c => c.ownerId === activeUnit.id);
    const card = cards[randomInt(0, cards.length - 1)];

    if (card.type === "single") {
      const targets = getAlive(playerTeam);
      if (targets.length === 0) return;
      const target = targets[randomInt(0, targets.length - 1)];
      enemyPlaySingle(card, target);
    } else {
      enemyPlayAoE(card);
    }
  }

  function enemyPlaySingle(card, target) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead || target.isDead) return;

    const res = calculateDamage(caster, target, card.VC);
    target.receiveDamage(res.damage);

    logCritDetails(caster, target, card, res, "enemy");

    if (target.isDead) {
      log(`${target.name} è stato sconfitto.`, "system");
    }

    updateUI();
    if (!checkEnd()) {
      turnNumber++;
      startNewPlayerTurn();
    }
  }

  function enemyPlayAoE(card) {
    const caster = getCharById(card.ownerId);
    if (!caster || caster.isDead) return;
    const enemies = getAlive(playerTeam);
    if (enemies.length === 0) return;

    log(`${caster.name} (nemico) usa ${card.name} (AoE)`, "enemy");

    for (const target of enemies) {
      const res = calculateDamage(caster, target, card.VC);
      target.receiveDamage(res.damage);

      logCritDetails(caster, target, card, res, "enemy");

      if (target.isDead) {
        log(`${target.name} è stato sconfitto.`, "system");
      }
    }

    updateUI();
    if (!checkEnd()) {
      turnNumber++;
      startNewPlayerTurn();
    }
  }

  /*********************
   * Eventi UI
   *********************/
  document.getElementById("end-turn-btn").addEventListener("click", () => {
    if (activeSide === "player" && !checkEnd()) {
      enemyTurnAuto();
    }
  });

  document.getElementById("new-hand-btn").addEventListener("click", () => {
    if (activeSide === "player" && !checkEnd()) {
      turnNumber++;
      startNewPlayerTurn();
    }
  });

  /*********************
   * Init
   *********************/
  function init() {
    log("Inizio test combattimento 3vs3.", "system");
    startNewPlayerTurn();
    updateUI();
  }

  init();
</script>
</body>
</html>
