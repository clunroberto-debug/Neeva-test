<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Neeva â€“ Prototype</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
    }
    h1, h2, h3 {
      margin: 0.4rem 0;
    }
    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1rem;
    }
    .board {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .panel {
      flex: 1;
      padding: 0.75rem;
      border-radius: 0.5rem;
      background: #020617;
      border: 1px solid #1f2937;
    }
    .panel h2 {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }
    .hero {
      border-radius: 0.5rem;
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border: 1px solid #374151;
      cursor: pointer;
    }
    .hero.selected-target {
      outline: 2px solid #fbbf24;
    }
    .hero h3 {
      font-size: 1rem;
    }
    .stat-line {
      font-size: 0.85rem;
      line-height: 1.3;
    }
    .stat-bonus {
      color: #22c55e;
    }
    .hp-bar {
      width: 100%;
      height: 10px;
      background: #374151;
      border-radius: 999px;
      overflow: hidden;
      margin: 0.25rem 0 0.4rem;
    }
    .hp-fill {
      height: 100%;
      background: #22c55e;
    }

    .hand {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .card {
      flex: 0 0 180px;
      border-radius: 0.5rem;
      border: 1px solid #4b5563;
      padding: 0.4rem 0.5rem;
      background: #111827;
      font-size: 0.8rem;
      cursor: pointer;
      position: relative;
    }
    .card.used {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .card.selected {
      outline: 2px solid #3b82f6;
    }
    .card-title {
      font-weight: 600;
      margin-bottom: 0.15rem;
    }
    .card-cost {
      position: absolute;
      top: 4px;
      right: 6px;
      font-size: 0.7rem;
      padding: 0.1rem 0.3rem;
      border-radius: 999px;
      background: #0f172a;
      border: 1px solid #1d4ed8;
    }
    .card-type {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-bottom: 0.15rem;
    }
    .card-desc {
      font-size: 0.75rem;
      line-height: 1.25;
    }

    .controls {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    button {
      border-radius: 0.5rem;
      border: none;
      padding: 0.4rem 0.7rem;
      font-size: 0.8rem;
      cursor: pointer;
      background: #1d4ed8;
      color: #e5e7eb;
    }
    button.secondary {
      background: #374151;
    }
    button.danger {
      background: #b91c1c;
    }
    button:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }
    .mana {
      font-size: 0.9rem;
    }

    .log {
      margin-top: 1rem;
      padding: 0.5rem 0.6rem;
      background: #020617;
      border-radius: 0.5rem;
      border: 1px solid #1f2937;
      font-size: 0.8rem;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Neeva â€“ Prototype Turno a Carte</h1>
    <p style="font-size:0.85rem;opacity:0.8;">
      Turno: Pescata 3 â†’ Mana pieno â†’ scegli carte (il mana scala ma le carte non si attivano) â†’ <b>Risolvi turno</b> â†’ gioca il bot.
    </p>

    <div class="board">
      <div class="panel" id="player-panel">
        <h2>Tu</h2>
        <div class="hero" id="player-hero" onclick="onHeroClick('bot')">
          <h3>Basil (Tu)</h3>
          <div class="hp-bar"><div class="hp-fill" id="player-hp-fill"></div></div>
          <div class="stat-line" id="player-stats"></div>
        </div>
      </div>
      <div class="panel" id="bot-panel">
        <h2>Bot</h2>
        <div class="hero" id="bot-hero" onclick="onHeroClick('player')">
          <h3>Mordel (Bot)</h3>
          <div class="hp-bar"><div class="hp-fill" id="bot-hp-fill"></div></div>
          <div class="stat-line" id="bot-stats"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>La tua mano</h2>
      <div class="mana" id="mana-display"></div>
      <div class="hand" id="hand"></div>
      <div class="controls">
        <button onclick="resolveTurn()" id="resolve-btn">Risolvi turno</button>
        <button class="secondary" onclick="resetTurn()" id="reset-btn">Reset turno</button>
        <button class="secondary" onclick="startNewGame()">Nuova partita</button>
        <span id="info" style="font-size:0.8rem;opacity:0.8;"></span>
      </div>
    </div>

    <div class="log" id="log"></div>
  </div>

  <script>
    // =========================
    // DEFINIZIONI DI BASE
    // =========================
    const MAX_MANA = 7;
    const INITIAL_HAND = 7;
    const DRAW_PER_TURN = 3;

    const cardDefinitions = {
      // Solo pochi esempi per il prototipo
      // type: 'attack' | 'buffSelf' | 'buffAllies' ...
      // target: 'enemy' | 'ally' | 'self' | 'aoeEnemy'
      "basil_basic_strike": {
        id: "basil_basic_strike",
        owner: "Basil",
        name: "Colpo di Scisto",
        cost: 1,
        type: "attack",
        target: "enemy",
        aoe: false,
        vc: 0.40,
        desc: "Basil â€“ Attacco singolo VC 40%.",
      },
      "basil_shield": {
        id: "basil_shield",
        owner: "Basil",
        name: "Muro di Scisti",
        cost: 2,
        type: "buffSelf",
        target: "self",
        aoe: false,
        desc: "Basil â€“ +5 DEF permanente e cura 20 HP.",
      },
      "basil_aoe": {
        id: "basil_aoe",
        owner: "Basil",
        name: "Fronte Minerale (AOE)",
        cost: 3,
        type: "attack",
        target: "aoeEnemy",
        aoe: true,
        vc: 0.30,
        desc: "Basil â€“ Attacco AOE VC 30%. Non richiede bersaglio.",
      },
      "mordel_basic_strike": {
        id: "mordel_basic_strike",
        owner: "Mordel",
        name: "Artiglio della Terra",
        cost: 1,
        type: "attack",
        target: "enemy",
        aoe: false,
        vc: 0.40,
        desc: "Mordel â€“ Attacco singolo VC 40%.",
      },
      "mordel_debuff": {
        id: "mordel_debuff",
        owner: "Mordel",
        name: "Sotterramento",
        cost: 2,
        type: "debuff",
        target: "enemy",
        aoe: false,
        desc: "Mordel â€“ -5 DEF permanente al bersaglio.",
      },
      "mordel_aoe": {
        id: "mordel_aoe",
        owner: "Mordel",
        name: "Crepa Tellurica (AOE)",
        cost: 3,
        type: "attack",
        target: "aoeEnemy",
        aoe: true,
        vc: 0.25,
        desc: "Mordel â€“ Attacco AOE VC 25%. Non richiede bersaglio.",
      }
    };

    // =========================
    // STATO DI GIOCO
    // =========================
    let game = null;
    let turnBackup = null; // snapshot JSON per reset turno
    let selectedCardIndex = null; // indice carta selezionata nella mano
    let pendingPlays = []; // queue delle carte da risolvere
    let selectingTargetFor = null; // { cardIndex, cardId }

    function createInitialGameState() {
      return {
        turnNumber: 1,
        currentPlayer: "player", // "player" o "bot"
        player: {
          name: "Basil",
          maxHp: 1000,
          hp: 1000,
          baseAtk: 80,
          baseDef: 40,
          atkBonus: 0,
          defBonus: 0
        },
        bot: {
          name: "Mordel",
          maxHp: 1000,
          hp: 1000,
          baseAtk: 75,
          baseDef: 35,
          atkBonus: 0,
          defBonus: 0
        },
        playerMana: MAX_MANA,
        botMana: MAX_MANA,
        playerDeck: [],
        botDeck: [],
        playerHand: [],
        botHand: [],
        playerGraveyard: [],
        botGraveyard: []
      };
    }

    function buildDeck(owner) {
      // Deck molto semplice per il prototipo
      const ids = owner === "player"
        ? [
            "basil_basic_strike",
            "basil_basic_strike",
            "basil_basic_strike",
            "basil_shield",
            "basil_shield",
            "basil_aoe",
            "basil_aoe"
          ]
        : [
            "mordel_basic_strike",
            "mordel_basic_strike",
            "mordel_basic_strike",
            "mordel_debuff",
            "mordel_debuff",
            "mordel_aoe",
            "mordel_aoe"
          ];
      // semplice shuffle
      for (let i = ids.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [ids[i], ids[j]] = [ids[j], ids[i]];
      }
      return ids;
    }

    function drawCards(owner, n) {
      const deckKey = owner === "player" ? "playerDeck" : "botDeck";
      const handKey = owner === "player" ? "playerHand" : "botHand";
      for (let i = 0; i < n; i++) {
        if (game[deckKey].length === 0) break;
        if (game[handKey].length >= 11) break; // limite mano
        const cardId = game[deckKey].shift();
        game[handKey].push({ id: cardId, used: false });
      }
    }

    function log(msg) {
      const logEl = document.getElementById("log");
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function startNewGame() {
      game = createInitialGameState();
      game.playerDeck = buildDeck("player");
      game.botDeck = buildDeck("bot");
      pendingPlays = [];
      selectedCardIndex = null;
      selectingTargetFor = null;

      // mano iniziale 7
      drawCards("player", INITIAL_HAND);
      drawCards("bot", INITIAL_HAND);

      // snapshot inizio turno per reset
      turnBackup = JSON.stringify(game);
      render();
      log("Nuova partita iniziata. Tocca a te (Turno 1).");
    }

    // =========================
    // RENDER UI
    // =========================
    function render() {
      renderHeroes();
      renderHand();
      renderMana();
      updateInfo();
    }

    function renderHeroes() {
      const p = game.player;
      const b = game.bot;

      // player
      let pAtkTotal = p.baseAtk + p.atkBonus;
      let pDefTotal = p.baseDef + p.defBonus;
      document.getElementById("player-stats").innerHTML =
        `HP: ${p.hp}/${p.maxHp}<br>` +
        `ATK: ${p.baseAtk} <span class="stat-bonus">(+${p.atkBonus})</span> = ${pAtkTotal}<br>` +
        `DEF: ${p.baseDef} <span class="stat-bonus">(+${p.defBonus})</span> = ${pDefTotal}`;

      const pFill = document.getElementById("player-hp-fill");
      pFill.style.width = Math.max(0, (p.hp / p.maxHp) * 100) + "%";

      // bot
      let bAtkTotal = b.baseAtk + b.atkBonus;
      let bDefTotal = b.baseDef + b.defBonus;
      document.getElementById("bot-stats").innerHTML =
        `HP: ${b.hp}/${b.maxHp}<br>` +
        `ATK: ${b.baseAtk} <span class="stat-bonus">(+${b.atkBonus})</span> = ${bAtkTotal}<br>` +
        `DEF: ${b.baseDef} <span class="stat-bonus">(+${b.defBonus})</span> = ${bDefTotal}`;

      const bFill = document.getElementById("bot-hp-fill");
      bFill.style.width = Math.max(0, (b.hp / b.maxHp) * 100) + "%";

      // target highlight (se stiamo scegliendo un bersaglio)
      document.getElementById("player-hero").classList.remove("selected-target");
      document.getElementById("bot-hero").classList.remove("selected-target");
      if (selectingTargetFor) {
        const cardDef = cardDefinitions[selectingTargetFor.cardId];
        if (cardDef.target === "enemy") {
          // se il giocatore usa una carta, il nemico Ã¨ il bot
          if (game.currentPlayer === "player") {
            document.getElementById("bot-hero").classList.add("selected-target");
          } else {
            document.getElementById("player-hero").classList.add("selected-target");
          }
        } else if (cardDef.target === "ally" || cardDef.target === "self") {
          if (game.currentPlayer === "player") {
            document.getElementById("player-hero").classList.add("selected-target");
          } else {
            document.getElementById("bot-hero").classList.add("selected-target");
          }
        }
      }
    }

    function renderHand() {
      const handEl = document.getElementById("hand");
      handEl.innerHTML = "";
      if (game.currentPlayer !== "player") return;

      game.playerHand.forEach((c, index) => {
        const def = cardDefinitions[c.id];
        const cardDiv = document.createElement("div");
        cardDiv.className = "card";
        if (c.used) cardDiv.classList.add("used");
        if (selectedCardIndex === index) cardDiv.classList.add("selected");

        const fullName = `${def.owner} â€“ ${def.name}`;

        cardDiv.innerHTML = `
          <div class="card-title">${fullName}</div>
          <div class="card-cost">${def.cost}ðŸ’§</div>
          <div class="card-type">${def.aoe ? "AOE " : ""}${def.type}</div>
          <div class="card-desc">${def.desc}</div>
        `;
        cardDiv.onclick = () => onCardClick(index);
        handEl.appendChild(cardDiv);
      });
    }

    function renderMana() {
      const mana = game.playerMana;
      document.getElementById("mana-display").textContent =
        `Mana: ${mana}/${MAX_MANA} | Carte in mano: ${game.playerHand.length}`;
    }

    function updateInfo(message) {
      const infoEl = document.getElementById("info");
      if (message) {
        infoEl.textContent = message;
      } else if (selectingTargetFor) {
        infoEl.textContent = "Seleziona un bersaglio cliccando sul PG giusto.";
      } else {
        infoEl.textContent = "Seleziona carte (il mana scala), poi clicca su 'Risolvi turno'.";
      }
    }

    // =========================
    // INTERAZIONE GIOCATORE
    // =========================
    function onCardClick(index) {
      if (game.currentPlayer !== "player") return;
      const card = game.playerHand[index];
      if (card.used) return;

      const def = cardDefinitions[card.id];
      if (def.cost > game.playerMana) {
        updateInfo("Mana insufficiente per questa carta.");
        return;
      }

      // AOE: non richiede bersaglio â†’ si aggiunge direttamente alla coda
      if (def.aoe || def.target === "self") {
        game.playerMana -= def.cost;
        card.used = true;
        pendingPlays.push({
          owner: "player",
          cardId: card.id,
          target: null
        });
        render();
        updateInfo(def.aoe ? "Carta AOE aggiunta alla coda." : "Carta aggiunta alla coda.");
        return;
      }

      // Carta a bersaglio singolo â†’ entra in modalitÃ  selezione bersaglio
      selectedCardIndex = index;
      selectingTargetFor = { cardIndex: index, cardId: card.id };
      render();
      updateInfo("Seleziona il bersaglio cliccando sul PG.");
    }

    function onHeroClick(sideClicked) {
      // sideClicked: "player" o "bot" â†’ chi Ã¨ stato cliccato
      if (!selectingTargetFor) return;
      if (game.currentPlayer !== "player") return;

      const card = game.playerHand[selectingTargetFor.cardIndex];
      const def = cardDefinitions[card.id];

      // Controllo coerenza bersaglio
      if (def.target === "enemy" && sideClicked === "player") {
        updateInfo("Questa carta richiede un NEMICO come bersaglio.");
        return;
      }
      if ((def.target === "ally" || def.target === "self") && sideClicked === "bot") {
        updateInfo("Questa carta richiede un ALLEATO come bersaglio.");
        return;
      }

      // Scala mana, marca la carta, aggiunge alla coda
      if (def.cost > game.playerMana) {
        updateInfo("Mana insufficiente.");
        return;
      }

      game.playerMana -= def.cost;
      card.used = true;
      pendingPlays.push({
        owner: "player",
        cardId: card.id,
        target: sideClicked // "player" o "bot"
      });

      // Esce da modalitÃ  selezione
      selectedCardIndex = null;
      selectingTargetFor = null;
      render();
      updateInfo("Carta aggiunta alla coda. Puoi selezionare altre carte o 'Risolvi turno'.");
    }

    function resetTurn() {
      if (!turnBackup) return;
      game = JSON.parse(turnBackup);
      pendingPlays = [];
      selectedCardIndex = null;
      selectingTargetFor = null;
      render();
      log("Turno resettato allo stato iniziale del turno.");
    }

    function resolveTurn() {
      if (game.currentPlayer !== "player") return;
      if (pendingPlays.length === 0) {
        updateInfo("Non hai selezionato nessuna carta da risolvere.");
        return;
      }

      log(`--- Risoluzione carte giocatore (Turno ${game.turnNumber}) ---`);
      // Applica in ordine
      for (const play of pendingPlays) {
        resolveCard(play);
      }
      pendingPlays = [];
      selectedCardIndex = null;
      selectingTargetFor = null;

      checkEndGame();
      if (isGameOver()) return;

      // Fine turno giocatore â†’ tocca al bot
      game.currentPlayer = "bot";
      render();
      setTimeout(botTurn, 600);
    }

    // =========================
    // RISOLUZIONE CARTE
    // =========================
    function getUnit(side) {
      return side === "player" ? game.player : game.bot;
    }

    function resolveCard(play) {
      const def = cardDefinitions[play.cardId];
      const ownerUnit = play.owner === "player" ? game.player : game.bot;
      const enemyUnit = play.owner === "player" ? game.bot : game.player;

      log(`${def.owner} usa ${def.name}.`);

      switch (def.type) {
        case "attack":
          if (def.target === "aoeEnemy") {
            // In questo prototipo Ã¨ 1v1, quindi AOE = singolo
            const dmg = computeDamage(ownerUnit, enemyUnit, def.vc || 0.3);
            enemyUnit.hp = Math.max(0, enemyUnit.hp - dmg);
            log(`Attacco AOE colpisce ${enemyUnit.name} per ${dmg} danni.`);
          } else {
            const targetUnit = play.target === "player"
              ? (play.owner === "player" ? game.player : game.bot)
              : (play.owner === "player" ? game.bot : game.player);
            const dmg = computeDamage(ownerUnit, targetUnit, def.vc || 0.4);
            targetUnit.hp = Math.max(0, targetUnit.hp - dmg);
            log(`${ownerUnit.name} infligge ${dmg} danni a ${targetUnit.name}.`);
          }
          break;
        case "buffSelf":
          ownerUnit.defBonus += 5;
          ownerUnit.hp = Math.min(ownerUnit.maxHp, ownerUnit.hp + 20);
          log(`${ownerUnit.name} guadagna +5 DEF permanente e cura 20 HP.`);
          break;
        case "debuff":
          // -5 DEF permanente al bersaglio
          const target = play.owner === "player" ? game.bot : game.player;
          target.defBonus -= 5;
          log(`${target.name} perde 5 DEF permanenti.`);
          break;
        default:
          log("Tipo carta non implementato nel prototipo.");
      }

      render();
      checkEndGame();
    }

    function computeDamage(attacker, defender, vc) {
      const atk = attacker.baseAtk + attacker.atkBonus;
      const def = defender.baseDef + defender.defBonus;
      const raw = Math.floor(atk * vc);
      const dmg = Math.max(0, raw - def);
      return dmg;
    }

    function checkEndGame() {
      if (game.player.hp <= 0 && game.bot.hp <= 0) {
        log("Pareggio: entrambi sconfitti.");
      } else if (game.player.hp <= 0) {
        log("Hai perso.");
      } else if (game.bot.hp <= 0) {
        log("Hai vinto!");
      }
    }

    function isGameOver() {
      return game.player.hp <= 0 || game.bot.hp <= 0;
    }

    // =========================
    // TURNO DEL BOT
    // =========================
    function botTurn() {
      if (isGameOver()) return;

      // Inizio turno bot: mana full + pescata 3 + snapshot per reset interno (anche se non la usiamo)
      game.botMana = MAX_MANA;
      drawCards("bot", DRAW_PER_TURN);
      render();
      log(`--- Turno ${game.turnNumber} del BOT ---`);

      // Semplice IA: gioca fino a 2 carte se ha mana
      let plays = 0;
      while (plays < 2) {
        const playableIndices = game.botHand
          .map((c, idx) => ({ c, idx }))
          .filter(obj => !obj.c.used && cardDefinitions[obj.c.id].cost <= game.botMana);
        if (playableIndices.length === 0) break;

        const choice = playableIndices[Math.floor(Math.random() * playableIndices.length)];
        const cardId = choice.c.id;
        const def = cardDefinitions[cardId];

        game.botMana -= def.cost;
        choice.c.used = true;

        const play = {
          owner: "bot",
          cardId: cardId,
          target: null
        };

        if (!def.aoe && def.target === "enemy") {
          play.target = "player";
        } else if (!def.aoe && (def.target === "ally" || def.target === "self")) {
          play.target = "bot";
        }

        resolveCard(play);
        if (isGameOver()) break;
        plays++;
      }

      if (!isGameOver()) {
        // Fine turno bot â†’ nuovo turno giocatore
        game.turnNumber += 1;
        startPlayerTurn();
      }
    }

    function startPlayerTurn() {
      game.currentPlayer = "player";
      game.playerMana = MAX_MANA;
      drawCards("player", DRAW_PER_TURN);
      pendingPlays = [];
      selectedCardIndex = null;
      selectingTargetFor = null;
      turnBackup = JSON.stringify(game); // snapshot per reset turno
      render();
      log(`--- Turno ${game.turnNumber} tuo ---`);
    }

    // =========================
    // AVVIO
    // =========================
    window.onload = () => {
      startNewGame();
    };
  </script>
</body>
</html>
