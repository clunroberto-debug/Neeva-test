<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Neeva Test Engine</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
    }
    header {
      padding: 10px 16px;
      background: #020617;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      font-size: 18px;
      margin: 0;
    }
    header small {
      color: #9ca3af;
    }
    main {
      padding: 12px;
      display: grid;
      grid-template-columns: 1.3fr 0.7fr;
      gap: 12px;
    }
    .column {
      background: #020617;
      border-radius: 8px;
      padding: 10px;
      border: 1px solid #1f2937;
    }
    .section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
      border-bottom: 1px solid #1f2937;
      padding-bottom: 4px;
    }
    .team {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .char-card {
      background: #111827;
      border-radius: 6px;
      padding: 6px;
      border: 1px solid #374151;
      width: 160px;
      cursor: pointer;
    }
    .char-card.enemy {
      border-color: #7f1d1d;
    }
    .char-card.selected-target {
      box-shadow: 0 0 0 2px #e5e7eb;
    }
    .char-name {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 2px;
    }
    .hp-bar {
      height: 6px;
      background: #1f2937;
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 4px;
    }
    .hp-fill {
      height: 100%;
      background: #22c55e;
    }
    .stat-line {
      font-size: 11px;
      color: #9ca3af;
      line-height: 1.2;
    }
    .buff-tags, .debuff-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }
    .tag {
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 999px;
      border: 1px solid;
    }
    .tag.buff {
      border-color: #22c55e;
      color: #bbf7d0;
    }
    .tag.debuff {
      border-color: #f97316;
      color: #fed7aa;
    }
    .hand {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .card-btn {
      background: #0f172a;
      border-radius: 6px;
      border: 1px solid #374151;
      padding: 6px;
      min-width: 150px;
      cursor: pointer;
      font-size: 11px;
      text-align: left;
      position: relative;
    }
    .card-btn.player {
      border-color: #4b5563;
    }
    .card-btn.pending {
      outline: 2px solid #22c55e;
    }
    .card-name {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 2px;
    }
    .card-cost {
      position: absolute;
      top: 3px;
      right: 4px;
      font-size: 11px;
      background: #111827;
      padding: 1px 4px;
      border-radius: 999px;
      border: 1px solid #4b5563;
    }
    .card-desc {
      font-size: 10px;
      color: #9ca3af;
    }
    .card-owner {
      font-size: 10px;
      color: #e5e7eb;
      margin-bottom: 2px;
    }

    .controls {
      margin-top: 8px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    button {
      background: #1d4ed8;
      border: none;
      color: white;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    button.secondary {
      background: #374151;
    }
    button.danger {
      background: #b91c1c;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .log {
      font-size: 11px;
      max-height: 280px;
      overflow-y: auto;
      background: #020617;
      border-radius: 6px;
      border: 1px solid #1f2937;
      padding: 6px;
      white-space: pre-line;
    }
    .log-line {
      margin-bottom: 2px;
    }
    .log-turn {
      color: #60a5fa;
      font-weight: 600;
    }
    .mana-label {
      font-size: 12px;
      margin-bottom: 4px;
    }
    .mana-value {
      font-weight: 700;
    }
    .pending-list {
      font-size: 11px;
      margin-top: 4px;
      background: #020617;
      border-radius: 6px;
      border: 1px dashed #4b5563;
      padding: 4px;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Neeva — Prototype Engine</h1>
      <small>Turni globali, deck, buff/debuff con keyword, scarti & reshuffle</small>
    </div>
    <div style="font-size:12px;color:#9ca3af">
      Giocatore: <strong>Player</strong> vs <strong>Bot</strong>
    </div>
  </header>

  <main>
    <!-- COLONNA SINISTRA: Campo + Mano -->
    <div class="column">
      <div class="section-title">Campo di Battaglia</div>
      <div class="mana-label">
        Turno globale <span id="turnNumber">1</span> —
        Mana: <span class="mana-value" id="playerMana">0</span> / 7
      </div>

      <div style="font-size:11px;color:#9ca3af;margin-bottom:4px">
        Fase: <span id="phaseLabel">-</span>
      </div>

      <div>
        <div style="font-size:12px;font-weight:600;margin-bottom:2px;">Il tuo team</div>
        <div class="team" id="playerTeam"></div>
      </div>

      <div>
        <div style="font-size:12px;font-weight:600;margin:6px 0 2px;">Team avversario</div>
        <div class="team" id="botTeam"></div>
      </div>

      <div style="margin-top:10px;">
        <div class="section-title">Le tue carte in mano</div>
        <div class="hand" id="playerHand"></div>
        <div class="pending-list">
          <div style="font-weight:600;margin-bottom:2px;">Carte in coda per questo turno:</div>
          <div id="pendingPlaysList" style="font-size:11px;color:#e5e7eb;">(nessuna)</div>
        </div>
      </div>

      <div class="controls">
        <button id="btnResolve" disabled>Risolvi carte & fine turno</button>
        <button id="btnResetTurn" class="secondary" disabled>Reset turno (annulla selezioni)</button>
      </div>
    </div>

    <!-- COLONNA DESTRA: Log + Info Deck -->
    <div class="column">
      <div class="section-title">Log di gioco</div>
      <div id="log" class="log"></div>

      <div style="margin-top:10px;">
        <div class="section-title">Deck & Scarti</div>
        <div style="font-size:11px;color:#9ca3af;">
          Carte nel deck: <span id="deckCount">0</span><br/>
          Carte negli scarti: <span id="discardCount">0</span>
        </div>
      </div>
    </div>
  </main>

  <script>
    /****************************************************
     * MODELLO BASE
     ****************************************************/

    const VC_TYPES = {
      SIMPLE: "simpleAttack",
      AOE: "aoeAttack",
      BUFF: "buff",
      DEBUFF: "debuff",
      UTILITY: "utility",
      ULTI: "ultimate"
    };

    // Stato di gioco
    const gameState = {
      globalTurn: 1,          // 1 = tuo, 2 = bot, 3 = tuo, ecc.
      currentSide: "player",  // "player" | "bot"
      phase: "idle",          // "draw", "play", "resolve", "enemy", "ended"
      playerMana: 0,
      playerManaMax: 7,
      playerDeck: [],
      playerDiscard: [],
      playerHand: [],
      pendingPlays: [],       // {card, sourceId, targetIds: [charId]}
      playerTeam: [],
      botTeam: [],
      selectedCardId: null,
      selectedTargets: [],
      targetMode: null,       // "enemySingle", "allySingle", "allyAll", "enemyAll", null
      mustSelectTarget: false,
      targetSide: null        // "player" | "bot"
    };

    /****************************************************
     * PERSONAGGI (3v3 per ora)
     ****************************************************/

    function createCharacter(id, name, side, stats) {
      return {
        id,
        name,
        side, // "player" | "bot"
        base: { ...stats },
        current: { ...stats },
        shield: 0,
        buffs: [],   // [{keyword, remainingTurns, stacks, meta}]
        debuffs: [], // idem
        alive: true
      };
    }

    function initTeams() {
      gameState.playerTeam = [
        createCharacter("basil", "Basil", "player", {
          lp: 980, lpMax: 980, atk: 63, def: 27,
          critChance: 60, critDmg: 120,
          critResist: 22, critDef: 47
        }),
        createCharacter("gael", "Gael", "player", {
          lp: 900, lpMax: 900, atk: 72, def: 11,
          critChance: 30, critDmg: 150,
          critResist: 10, critDef: 25
        }),
        createCharacter("zagrok", "Zagrok", "player", {
          lp: 830, lpMax: 830, atk: 68, def: 13,
          critChance: 30, critDmg: 150,
          critResist: 30, critDef: 20
        })
      ];

      gameState.botTeam = [
        createCharacter("mordel", "Mordel", "bot", {
          lp: 1020, lpMax: 1020, atk: 60, def: 32,
          critChance: 25, critDmg: 150,
          critResist: 25, critDef: 33
        }),
        createCharacter("kiddou", "Kiddou", "bot", {
          lp: 820, lpMax: 820, atk: 58, def: 23,
          critChance: 40, critDmg: 160,
          critResist: 20, critDef: 26
        }),
        createCharacter("rindu", "Rindu", "bot", {
          lp: 860, lpMax: 860, atk: 78, def: 28,
          critChance: 28, critDmg: 150,
          critResist: 20, critDef: 22
        })
      ];
    }

    /****************************************************
     * CARTE (stesso set che avevi prima)
     ****************************************************/

   const allCards = [
  /*************************
   * BASIL — Tank Support
   *************************/

  {
    id: "basil_colpo_scisto",
    name: "Basil — Colpo di Scisto",
    owner: "Basil",
    cost: 1,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.40,
    desc: "Attacco singolo (VC 40%).",
    effect: (source, targets) => {
      const t = targets[0];
      simpleAttack(source, t, 0.40);
    }
  },
  {
    id: "basil_muro_scisti",
    name: "Basil — Muro di Scisti",
    owner: "Basil",
    cost: 2,
    type: VC_TYPES.BUFF,
    target: "allySingle",
    desc: "Scudo = 12% LPmax di Basil (2 turni) +10 DEF (1 turno).",
    effect: (source, targets) => {
      const t = targets[0];
      const shieldAmount = Math.round(source.current.lpMax * 0.12);
      t.shield += shieldAmount;
      addBuff(t, {
        keyword: "Muro di Scisti",
        visible: true,
        remainingTurns: 1,
        data: { defBonus: 10 }
      });
      t.current.def += 10;
      logLine(`${t.name} ottiene uno scudo di ${shieldAmount} e +10 DEF (1 turno).`);
    }
  },
  {
    id: "basil_disgelo",
    name: "Basil — Disgelo di Quarzo",
    owner: "Basil",
    cost: 3,
    type: VC_TYPES.UTILITY,
    target: "allyAll",
    desc: "Tutti gli alleati rimuovono 1 debuff e curano 30% LPmax di Basil. Basil +30 LP(P).",
    effect: (source, targets) => {
      const heal = Math.round(source.current.lpMax * 0.30);
      const allies = getTeam(source.side);
      allies.forEach(ch => {
        if (!ch.alive) return;
        if (ch.debuffs.length > 0) {
          const removed = ch.debuffs.shift();
          logLine(`Debuff ${removed.keyword} rimosso da ${ch.name}.`);
        }
        const before = ch.current.lp;
        ch.current.lp = Math.min(ch.current.lp + heal, ch.current.lpMax);
        const gained = ch.current.lp - before;
        if (gained > 0) {
          logLine(`${ch.name} cura ${gained} LP.`);
        }
      });
      source.current.lpMax += 30;
      source.current.lp += 30;
      logLine(`${source.name} ottiene +30 LP(P).`);
    }
  },
  {
    id: "basil_zoccolo_tellurico",
    name: "Basil — Zoccolo Tellurico",
    owner: "Basil",
    cost: 3,
    type: VC_TYPES.AOE,
    target: "enemyAll",
    vc: 0.70,
    desc: "AOE VC 70%. Applica Ferita x1 (3 turni) a tutti i nemici.",
    effect: (source, targets) => {
      const enemies = getOpposingTeam(source.side);
      enemies.forEach(t => {
        if (!t.alive) return;
        simpleAttack(source, t, 0.70);
        addDebuff(t, {
          keyword: "Ferita",
          visible: true,
          remainingTurns: 3,
          data: { stacks: 1 }
        });
        logLine(`${t.name} subisce Ferita x1 (3 turni).`);
      });
    }
  },

  /*************************
   * GAEL — Bruiser Difensivo
   *************************/

  {
    id: "gael_colpo_guardia",
    name: "Gael — Colpo di Guardia",
    owner: "Gael",
    cost: 1,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.55,
    desc: "Attacco singolo (VC 55%).",
    effect: (source, targets) => {
      simpleAttack(source, targets[0], 0.55);
    }
  },
  {
    id: "gael_resistenza_ferrea",
    name: "Gael — Resistenza Ferrea",
    owner: "Gael",
    cost: 2,
    type: VC_TYPES.BUFF,
    target: "allySelf",
    desc: "+25% DEF per 2 turni (solo Gael).",
    effect: (source, targets) => {
      const bonus = Math.round(source.current.def * 0.25);
      source.current.def += bonus;
      addBuff(source, {
        keyword: "Resistenza Ferrea",
        visible: true,
        remainingTurns: 2,
        data: { defBonus: bonus }
      });
      logLine(`${source.name} ottiene +${bonus} DEF per 2 turni.`);
    }
  },
  {
    id: "gael_sfida_guardiano",
    name: "Gael — Sfida del Guardiano",
    owner: "Gael",
    cost: 3,
    type: VC_TYPES.BUFF,
    target: "allySelf",
    desc: "2 turni: chi attacca un tuo alleato (eccetto Gael) subisce 35% ATK di Gael. Gael +10% LPmax(P).",
    effect: (source, targets) => {
      // Buff di reazione
      addBuff(source, {
        keyword: "Sfida del Guardiano",
        visible: true,
        remainingTurns: 2,
        data: { retaliateFactor: 0.35 }
      });
      const bonusLp = Math.round(source.current.lpMax * 0.10);
      source.current.lpMax += bonusLp;
      source.current.lp += bonusLp;
      logLine(`${source.name} attiva Sfida del Guardiano (2 turni) e ottiene +${bonusLp} LPmax(P).`);
    }
  },
  {
    id: "gael_lama_risoluta",
    name: "Gael — Lama Risoluta",
    owner: "Gael",
    cost: 2,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.80,
    desc: "VC 80%. Se infligge danno → rimuove 1 buff visibile al bersaglio.",
    effect: (source, targets) => {
      const t = targets[0];
      const dmg = simpleAttack(source, t, 0.80);
      if (dmg > 0 && t.buffs.length > 0) {
        // rimuovi il primo buff visibile
        const idx = t.buffs.findIndex(b => b.visible);
        if (idx >= 0) {
          const removed = t.buffs.splice(idx, 1)[0];
          logLine(`Il buff ${removed.keyword} viene rimosso da ${t.name}.`);
        }
      }
    }
  },

  /*************************
   * KIDDOU — Crit Support
   *************************/

  {
    id: "kiddou_colpo_risolutivo",
    name: "Kiddou — Colpo Risolutivo",
    owner: "Kiddou",
    cost: 1,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.45,
    desc: "Attacco singolo (VC 45%).",
    effect: (source, targets) => {
      simpleAttack(source, targets[0], 0.45);
    }
  },
  {
    id: "kiddou_richiamo_impetuoso",
    name: "Kiddou — Richiamo Impetuoso",
    owner: "Kiddou",
    cost: 2,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.65,
    desc: "VC 65%. Tutti gli alleati: +5% CritChance (1 turno).",
    effect: (source, targets) => {
      const t = targets[0];
      simpleAttack(source, t, 0.65);
      const allies = getTeam(source.side);
      allies.forEach(ch => {
        if (!ch.alive) return;
        addBuff(ch, {
          keyword: "Crit Buff",
          visible: false,
          remainingTurns: 1,
          data: { critChanceBonus: 5 }
        });
        ch.current.critChance += 5;
      });
      logLine(`Tutti gli alleati ottengono +5% CritChance (1 turno).`);
    }
  },
  {
    id: "kiddou_benedizione_infinita",
    name: "Kiddou — Benedizione Infinita",
    owner: "Kiddou",
    cost: 2,
    type: VC_TYPES.BUFF,
    target: "allyAll",
    desc: "Alleati: +8% CritChance (1 turno). Kiddou: +5 DEF(P).",
    effect: (source, targets) => {
      const allies = getTeam(source.side);
      allies.forEach(ch => {
        if (!ch.alive) return;
        addBuff(ch, {
          keyword: "Crit Buff",
          visible: false,
          remainingTurns: 1,
          data: { critChanceBonus: 8 }
        });
        ch.current.critChance += 8;
      });
      source.current.def += 5;
      logLine(`Tutti gli alleati ottengono +8% CritChance (1 turno). ${source.name} ottiene +5 DEF(P).`);
    }
  },
  {
    id: "kiddou_marchio_collasso",
    name: "Kiddou — Marchio del Collasso",
    owner: "Kiddou",
    cost: 3,
    type: VC_TYPES.DEBUFF,
    target: "enemySingle",
    desc: "Applica Rottura Critica x1 (2 turni).",
    effect: (source, targets) => {
      const t = targets[0];
      addDebuff(t, {
        keyword: "Rottura Critica",
        visible: true,
        remainingTurns: 2,
        data: { stacks: 1 }
      });
      logLine(`${t.name} ottiene Rottura Critica x1 (2 turni).`);
    }
  },

  /*************************
   * ZAGROK — Bruiser Offensivo
   *************************/

  {
    id: "zagrok_morso_virale",
    name: "Zagrok — Morso Virale",
    owner: "Zagrok",
    cost: 1,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.60,
    desc: "VC 60%. Se infligge danno → +10 LP(P).",
    effect: (source, targets) => {
      const t = targets[0];
      const dmg = simpleAttack(source, t, 0.60);
      if (dmg > 0) {
        source.current.lpMax += 10;
        source.current.lp += 10;
        logLine(`${source.name} guadagna +10 LP(P).`);
      }
    }
  },
  {
    id: "zagrok_sovraccarico",
    name: "Zagrok — Sovraccarico Cellulare",
    owner: "Zagrok",
    cost: 2,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.85,
    desc: "VC 85%. Se Zagrok ha un buff visibile → +4 ATK(P).",
    effect: (source, targets) => {
      const t = targets[0];
      simpleAttack(source, t, 0.85);
      if (source.buffs.some(b => b.visible)) {
        source.current.atk += 4;
        logLine(`${source.name} ottiene +4 ATK(P) da Sovraccarico Cellulare.`);
      }
    }
  },
  {
    id: "zagrok_ringiovanimento",
    name: "Zagrok — Ringiovanimento",
    owner: "Zagrok",
    cost: 3,
    type: VC_TYPES.BUFF,
    target: "allyAll",
    desc: "Alleati: Ringiovanimento (2 turni): ad ogni inizio turno +12% LPmax & cura equivalente.",
    effect: (source, targets) => {
      const allies = getTeam(source.side);
      allies.forEach(ch => {
        if (!ch.alive) return;
        addBuff(ch, {
          keyword: "Ringiovanimento",
          visible: true,
          activationsRemaining: 2, // 2 attivazioni: prossimo turno avversario + tuo
          data: { percent: 0.12 }
        });
        logLine(`${ch.name} ottiene Ringiovanimento (2 attivazioni).`);
      });
    }
  },
  {
    id: "zagrok_espansione_pandemica",
    name: "Zagrok — Espansione Pandemica",
    owner: "Zagrok",
    cost: 3,
    type: VC_TYPES.BUFF,
    target: "allyAll",
    desc: "Alleati: +8 ATK (1 turno). Zagrok: +12% LPmax(P).",
    effect: (source, targets) => {
      const allies = getTeam(source.side);
      allies.forEach(ch => {
        if (!ch.alive) return;
        addBuff(ch, {
          keyword: "Espansione Pandemica",
          visible: false,
          remainingTurns: 1,
          data: { atkBonus: 8 }
        });
        ch.current.atk += 8;
      });
      const gain = Math.round(source.current.lpMax * 0.12);
      source.current.lpMax += gain;
      source.current.lp += gain;
      logLine(`Tutti gli alleati ottengono +8 ATK (1 turno). ${source.name} ottiene +${gain} LPmax(P).`);
    }
  },

  /*************************
   * MORDEL — Tank Debuffer
   *************************/

  {
    id: "mordel_artiglio_terra",
    name: "Mordel — Artiglio della Terra Morta",
    owner: "Mordel",
    cost: 1,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.45,
    desc: "VC 45%. +20% danni finali se il nemico ha almeno un debuff.",
    effect: (source, targets) => {
      const t = targets[0];
      const hasDebuff = t.debuffs.length > 0;
      const bonus = hasDebuff ? 1.2 : 1.0;
      simpleAttack(source, t, 0.45, { finalMultiplier: bonus });
    }
  },
  {
    id: "mordel_tomba_pietra",
    name: "Mordel — Tomba di Pietra",
    owner: "Mordel",
    cost: 2,
    type: VC_TYPES.BUFF,
    target: "allySelf",
    desc: "Scudo 18% LPmax (2 turni). +10 DEF (1 turno).",
    effect: (source, targets) => {
      const shieldAmount = Math.round(source.current.lpMax * 0.18);
      source.shield += shieldAmount;
      addBuff(source, {
        keyword: "Tomba di Pietra",
        visible: true,
        remainingTurns: 1,
        data: { defBonus: 10 }
      });
      source.current.def += 10;
      logLine(`${source.name} ottiene Scudo ${shieldAmount} e +10 DEF (1 turno).`);
    }
  },
  {
    id: "mordel_sepoltura_lenta",
    name: "Mordel — Sepoltura Lenta",
    owner: "Mordel",
    cost: 2,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.50,
    desc: "VC 50%. Se infligge danno → 2 stack di Sotterramento (3 turni).",
    effect: (source, targets) => {
      const t = targets[0];
      const dmg = simpleAttack(source, t, 0.50);
      if (dmg > 0) {
        for (let i = 0; i < 2; i++) {
          addDebuff(t, {
            keyword: "Sotterramento",
            visible: true,
            remainingTurns: 3,
            data: { defPenalty: 5 }
          });
        }
        logLine(`${t.name} subisce 2 stack di Sotterramento (3 turni).`);
      }
    }
  },
  {
    id: "mordel_abisso_silente",
    name: "Mordel — Abisso Silente",
    owner: "Mordel",
    cost: 3,
    type: VC_TYPES.BUFF,
    target: "allyAll",
    desc: "Alleati (2 turni): Predatore Sotterraneo → +15% danni finali contro nemici con Sotterramento.",
    effect: (source, targets) => {
      const allies = getTeam(source.side);
      allies.forEach(ch => {
        if (!ch.alive) return;
        addBuff(ch, {
          keyword: "Predatore Sotterraneo",
          visible: true,
          remainingTurns: 2,
          data: { dmgBonusVsSot: 0.15 }
        });
        logLine(`${ch.name} ottiene Predatore Sotterraneo (2 turni).`);
      });
    }
  },

  /*************************
   * RINDU — Bruiser Offensivo
   *************************/

  {
    id: "rindu_colpo_crescente",
    name: "Rindu — Colpo Crescente",
    owner: "Rindu",
    cost: 1,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.45,
    desc: "VC 45%. Se infligge danno → attiva la passiva (una volta per turno).",
    effect: (source, targets) => {
      const t = targets[0];
      const dmg = simpleAttack(source, t, 0.45);
      if (dmg > 0) {
        tryTriggerRinduPassive(source);
      }
    }
  },
  {
    id: "rindu_lama_ascensionale",
    name: "Rindu — Lama Ascensionale",
    owner: "Rindu",
    cost: 2,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.65,
    desc: "VC 65%. Se il bersaglio <60% LP → +20% danni finali.",
    effect: (source, targets) => {
      const t = targets[0];
      const ratio = t.current.lp / t.current.lpMax;
      const bonus = ratio < 0.60 ? 1.2 : 1.0;
      const dmg = simpleAttack(source, t, 0.65, { finalMultiplier: bonus });
      if (dmg > 0) {
        tryTriggerRinduPassive(source);
      }
    }
  },
  {
    id: "rindu_taglio_catartico",
    name: "Rindu — Taglio Catartico",
    owner: "Rindu",
    cost: 3,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.80,
    desc: "VC 80%. Se infligge danno → Rindu +10 ATK(P).",
    effect: (source, targets) => {
      const t = targets[0];
      const dmg = simpleAttack(source, t, 0.80);
      if (dmg > 0) {
        source.current.atk += 10;
        logLine(`${source.name} ottiene +10 ATK(P) da Taglio Catartico.`);
        tryTriggerRinduPassive(source);
      }
    }
  },
  {
    id: "rindu_purificazione_vitale",
    name: "Rindu — Purificazione Vitale",
    owner: "Rindu",
    cost: 3,
    type: VC_TYPES.UTILITY,
    target: "allyAll",
    desc: "Tutti gli alleati rimuovono i debuff e curano 35% dell'ATK di Rindu.",
    effect: (source, targets) => {
      const heal = Math.round(source.current.atk * 0.35);
      const allies = getTeam(source.side);
      allies.forEach(ch => {
        if (!ch.alive) return;
        if (ch.debuffs.length > 0) {
          ch.debuffs = [];
          logLine(`Tutti i debuff vengono rimossi da ${ch.name}.`);
        }
        const before = ch.current.lp;
        ch.current.lp = Math.min(ch.current.lp + heal, ch.current.lpMax);
        const diff = ch.current.lp - before;
        if (diff > 0) {
          logLine(`${ch.name} cura ${diff} LP.`);
        }
      });
    }
  },

  /*************************
   * DIONERE — Bruiser “immortale”
   *************************/

  {
    id: "dionere_assalto_instabile",
    name: "Dionere — Assalto Instabile",
    owner: "Dionere",
    cost: 1,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.45,
    desc: "VC 45%. +20% danni finali se sotto il 50% LP.",
    effect: (source, targets) => {
      const t = targets[0];
      const ratio = source.current.lp / source.current.lpMax;
      const bonus = ratio < 0.5 ? 1.2 : 1.0;
      simpleAttack(source, t, 0.45, { finalMultiplier: bonus });
    }
  },
  {
    id: "dionere_falce_ritorno",
    name: "Dionere — Falce del Ritorno",
    owner: "Dionere",
    cost: 2,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.55,
    desc: "VC 55%. +20% danni (<60% LP), +40% (<30% LP).",
    effect: (source, targets) => {
      const t = targets[0];
      const ratio = source.current.lp / source.current.lpMax;
      let bonus = 1.0;
      if (ratio < 0.30) bonus = 1.4;
      else if (ratio < 0.60) bonus = 1.2;
      simpleAttack(source, t, 0.55, { finalMultiplier: bonus });
    }
  },
  {
    id: "dionere_ira_fenice",
    name: "Dionere — Ira della Fenice",
    owner: "Dionere",
    cost: 3,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.65,
    desc: "VC 65%. +25 danni fissi (1+ stack passiva), +50 (3+ stack).",
    effect: (source, targets) => {
      const t = targets[0];
      const baseDmg = simpleAttack(source, t, 0.65);
      const stacks = source.dionereStacks || 0;
      let bonusFixed = 0;
      if (stacks >= 3) bonusFixed = 50;
      else if (stacks >= 1) bonusFixed = 25;
      if (bonusFixed > 0 && t.alive) {
        applyDirectDamage(t, bonusFixed);
        logLine(`${source.name} infligge ${bonusFixed} danni fissi extra con Ira della Fenice.`);
      }
    }
  },
  {
    id: "dionere_taglio_rinascita",
    name: "Dionere — Taglio della Rinascita",
    owner: "Dionere",
    cost: 2,
    type: VC_TYPES.SIMPLE,
    target: "enemySingle",
    vc: 0.45,
    desc: "VC 45%. Cura del 20% del danno (40% se sotto 50% LP).",
    effect: (source, targets) => {
      const t = targets[0];
      const ratio = source.current.lp / source.current.lpMax;
      const healRatio = ratio < 0.5 ? 0.40 : 0.20;
      const dmg = simpleAttack(source, t, 0.45);
      if (dmg > 0) {
        const heal = Math.round(dmg * healRatio);
        const before = source.current.lp;
        source.current.lp = Math.min(source.current.lp + heal, source.current.lpMax);
        const diff = source.current.lp - before;
        if (diff > 0) {
          logLine(`${source.name} si cura di ${diff} LP grazie a Taglio della Rinascita.`);
        }
      }
    }
  },
  {
    id: "dionere_emorragia_oscura",
    name: "Dionere — Emorragia Oscura",
    owner: "Dionere",
    cost: 2,
    type: VC_TYPES.DEBUFF,
    target: "enemySingle",
    desc: "Perde 10% LPmax (non uccide). Applica Ferita x1 (3 turni). Se <35% LP → Ferita x2.",
    effect: (source, targets) => {
      // Self-damage 10% LPmax, non uccide mai
      const selfLoss = Math.round(source.current.lpMax * 0.10);
      source.current.lp = Math.max(1, source.current.lp - selfLoss);
      logLine(`${source.name} perde ${selfLoss} LP per Emorragia Oscura (non mortale).`);

      const t = targets[0];
      let stacks = 1;
      const ratio = source.current.lp / source.current.lpMax;
      if (ratio < 0.35) stacks = 2;

      for (let i = 0; i < stacks; i++) {
        addDebuff(t, {
          keyword: "Ferita",
          visible: true,
          remainingTurns: 3,
          data: { stacks: 1 }
        });
      }
      logLine(`${t.name} ottiene Ferita x${stacks} (3 turni).`);
    }
  },
  {
    id: "dionere_carico_disperato",
    name: "Dionere — Carico Disperato",
    owner: "Dionere",
    cost: 3,
    type: VC_TYPES.BUFF,
    target: "allySelf",
    desc: "2 turni: +30% ATK e +20% CritDmg (se sopra 50% LP → metà effetto).",
    effect: (source, targets) => {
      const ratio = source.current.lp / source.current.lpMax;
      const atkMult = ratio > 0.5 ? 0.15 : 0.30;
      const critMult = ratio > 0.5 ? 0.10 : 0.20;
      const atkBonus = Math.round(source.current.atk * atkMult);
      const critBonus = Math.round(source.current.critDmg * critMult);
      source.current.atk += atkBonus;
      source.current.critDmg += critBonus;
      addBuff(source, {
        keyword: "Carico Disperato",
        visible: true,
        remainingTurns: 2,
        data: { atkBonus, critBonus }
      });
      logLine(`${source.name} ottiene Carico Disperato: +${atkBonus} ATK, +${critBonus}% CritDmg (2 turni).`);
    }
  },
  {
    id: "dionere_ombra_protettiva",
    name: "Dionere — Ombra Protettiva",
    owner: "Dionere",
    cost: 3,
    type: VC_TYPES.BUFF,
    target: "allySelf",
    desc: "1 turno: -40% danni subiti. Se scende <40 LP → +12 ATK(P), +7 DEF(P), +10 CritDef(P).",
    effect: (source, targets) => {
      addBuff(source, {
        keyword: "Ombra Protettiva",
        visible: true,
        remainingTurns: 1,
        data: { triggered: false }
      });
      logLine(`${source.name} è protetta dall'Ombra Protettiva per 1 turno.`);
    }
  }
];
    function buildPlayerDeck() {
      // per ora 2 copie di ogni carta
      const baseIds = [
        "basil_base",
        "basil_muro",
        "basil_disgelo",
        "zagrok_ringiovanimento",
        "mordel_zoccolo_ferita",
        "gael_colpo_guardia",
        "zagrok_morso"
      ];
      const deck = [];
      baseIds.forEach(id => {
        const card = allCards.find(c => c.id === id);
        if (!card) return;
        deck.push({ ...card });
        deck.push({ ...card });
      });
      return deck;
    }

    /****************************************************
     * UTILI: TEAM, LOG
     ****************************************************/

    function getTeam(side) {
      return side === "player" ? gameState.playerTeam : gameState.botTeam;
    }

    function getOpposingTeam(side) {
      return side === "player" ? gameState.botTeam : gameState.playerTeam;
    }

    function findCharById(id) {
      return (
        gameState.playerTeam.find(c => c.id === id) ||
        gameState.botTeam.find(c => c.id === id)
      );
    }

    const logEl = document.getElementById("log");

    function logLine(text, isTurnHeader = false) {
      const div = document.createElement("div");
      div.className = "log-line" + (isTurnHeader ? " log-turn" : "");
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    /****************************************************
     * BUFF / DEBUFF ENGINE
     ****************************************************/

    // Le keyword "visibili"
    const VISIBLE_BUFFS = ["Ringiovanimento", "Predatore Sotterraneo"];
    const VISIBLE_DEBUFFS = ["Ferita", "Sotterramento", "Rottura Critica"];

    // Aggiungi buff (oggetto: {keyword, duration, data})
    function addBuff(character, effect) {
      if (!effect || !effect.keyword) return;
      const keyword = effect.keyword;
      const turns = effect.duration ?? 1;
      const meta = effect.data || {};
      const stacksToAdd = meta.stacks ? meta.stacks : 1;

      let buff = character.buffs.find(b => b.keyword === keyword);
      if (buff) {
        // stack massimo 5
        buff.stacks = Math.min(5, buff.stacks + stacksToAdd);
        // refresh durata al massimo tra attuale e nuova
        buff.remainingTurns = Math.max(buff.remainingTurns, turns);
      } else {
        character.buffs.push({
          keyword,
          remainingTurns: turns,
          stacks: Math.min(5, stacksToAdd),
          meta: { ...meta }
        });
      }
    }

    // Aggiungi debuff (oggetto: {keyword, duration, data})
    function addDebuff(character, effect) {
      if (!effect || !effect.keyword) return;
      const keyword = effect.keyword;
      const turns = effect.duration ?? 1;
      const meta = effect.data || {};
      const stacksToAdd = meta.stacks ? meta.stacks : 1;

      let deb = character.debuffs.find(d => d.keyword === keyword);
      if (deb) {
        deb.stacks = Math.min(5, deb.stacks + stacksToAdd);
        deb.remainingTurns = Math.max(deb.remainingTurns, turns);
      } else {
        character.debuffs.push({
          keyword,
          remainingTurns: turns,
          stacks: Math.min(5, stacksToAdd),
          meta: { ...meta }
        });
      }
    }

    // Effetti di INIZIO TURNO (globale 1,2,3,4...)
    function processStartOfTurnEffects() {
      [...gameState.playerTeam, ...gameState.botTeam].forEach(ch => {
        if (!ch.alive) return;

        ch.buffs.forEach(buff => {
          if (buff.keyword === "Ringiovanimento" && buff.remainingTurns > 0) {
            // percentuale per stack, si somma
            const perStack = buff.meta.percent ?? 0.12;
            const totalPercent = perStack * buff.stacks;
            const gain = Math.round(ch.current.lpMax * totalPercent);
            ch.current.lpMax += gain;
            ch.current.lp += gain;
            logLine(`${ch.name} (Ringiovanimento x${buff.stacks}): +${gain} LPmax & LP.`);
            buff.remainingTurns -= 1;
          }
          // altri buff start-of-turn in futuro
        });

        // pulizia buff che sono scaduti ed erano start-of-turn (Ringiovanimento)
        ch.buffs = ch.buffs.filter(buff => {
          if (buff.keyword === "Ringiovanimento" && buff.remainingTurns <= 0) {
            logLine(`Il buff Ringiovanimento su ${ch.name} è terminato.`);
            return false;
          }
          return true;
        });
      });
    }

    // Effetti di FINE TURNO (globale)
    function processEndOfTurnEffects() {
      [...gameState.playerTeam, ...gameState.botTeam].forEach(ch => {
        if (!ch.alive) return;

        // 1) Ferita: danno percentuale
        const ferita = ch.debuffs.find(d => d.keyword === "Ferita");
        if (ferita && ferita.remainingTurns > 0) {
          const stacks = ferita.stacks || 1;
          const percent = 0.07 * stacks;
          const rawLoss = Math.floor(ch.current.lp * percent);
          let loss = rawLoss;

          if (loss > 0) {
            // prima sullo scudo
            if (ch.shield > 0) {
              const absorbed = Math.min(ch.shield, loss);
              ch.shield -= absorbed;
              loss -= absorbed;
              logLine(`${ch.name} assorbe ${absorbed} danni da Ferita con lo Scudo.`);
            }
            if (loss > 0) {
              ch.current.lp = Math.max(0, ch.current.lp - loss);
              logLine(`${ch.name} perde ${loss} LP per Ferita (x${stacks}).`);
            }
          }

          ferita.remainingTurns -= 1;
        }

        // 2) decremento durata per gli altri buff/debuff "a tempo"
        ch.buffs.forEach(buff => {
          if (buff.keyword !== "Ringiovanimento") {
            if (buff.remainingTurns > 0) buff.remainingTurns -= 1;
          }
        });
        ch.debuffs.forEach(deb => {
          if (deb.keyword !== "Ferita") {
            if (deb.remainingTurns > 0) deb.remainingTurns -= 1;
          }
        });

        // 3) rimozione buff scaduti e gestione effetti di fine
        //    (solo per quelli che hanno effetti temporanei)
        const newBuffs = [];
        ch.buffs.forEach(buff => {
          if (buff.remainingTurns > 0 || buff.keyword === "Ringiovanimento") {
            newBuffs.push(buff);
          } else {
            if (buff.keyword === "Muro di Scisti") {
              const defBonus = buff.meta.defBonus || 0;
              ch.current.def -= defBonus;
              logLine(`Il buff Muro di Scisti su ${ch.name} è terminato.`);
            }
            if (buff.keyword === "Predatore Sotterraneo") {
              logLine(`Il buff Predatore Sotterraneo su ${ch.name} è terminato.`);
            }
          }
        });
        ch.buffs = newBuffs;

        const newDebuffs = [];
        ch.debuffs.forEach(deb => {
          if (deb.remainingTurns > 0 || deb.keyword === "Ferita") {
            newDebuffs.push(deb);
          } else {
            logLine(`Il debuff ${deb.keyword} su ${ch.name} è terminato.`);
          }
        });
        ch.debuffs = newDebuffs;
      });
    }

    /****************************************************
     * COMBATTIMENTO SEMPLIFICATO (per ora senza crit)
     ****************************************************/

    function simpleAttack(source, target, vc) {
      if (!source.alive || !target.alive) return 0;
      const raw = Math.round(source.current.atk * vc);

      let remaining = raw;

      // scudo prima
      if (target.shield > 0) {
        const absorbed = Math.min(target.shield, remaining);
        target.shield -= absorbed;
        remaining -= absorbed;
        logLine(`${target.name} assorbe ${absorbed} danni con lo Scudo.`);
      }

      if (remaining <= 0) {
        logLine(`${source.name} colpisce ${target.name}, ma non infligge danni ai LP.`);
        return 0;
      }

      const def = target.current.def;
      const dmg = Math.max(0, remaining - def);
      if (dmg <= 0) {
        logLine(`${source.name} colpisce ${target.name}, ma la DIFESA blocca il colpo.`);
        return 0;
      }

      target.current.lp = Math.max(0, target.current.lp - dmg);
      logLine(`${source.name} infligge ${dmg} danni a ${target.name}.`);

      if (target.current.lp <= 0) {
        target.alive = false;
        logLine(`${target.name} è stato sconfitto!`);
      }
      return dmg;
    }

    /****************************************************
     * DECK, PESCA, SCARTI
     ****************************************************/

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function drawCards(n) {
      for (let i = 0; i < n; i++) {
        if (gameState.playerDeck.length === 0) {
          if (gameState.playerDiscard.length > 0) {
            gameState.playerDeck = gameState.playerDiscard.splice(0);
            shuffle(gameState.playerDeck);
            logLine("Il deck è finito, rimescolo gli scarti (tranne le Ulti).");
          } else {
            logLine("Il deck è vuoto e non ci sono scarti, non puoi pescare.");
            break;
          }
        }
        const card = gameState.playerDeck.shift();
        gameState.playerHand.push(card);
      }
    }

    /****************************************************
     * TURNI & FASI (con turno globale)
     ****************************************************/

    function startGame() {
      initTeams();
      gameState.playerDeck = buildPlayerDeck();
      shuffle(gameState.playerDeck);
      gameState.playerDiscard = [];
      gameState.playerHand = [];
      gameState.pendingPlays = [];
      gameState.globalTurn = 1;
      gameState.currentSide = "player";
      gameState.playerManaMax = 7;
      gameState.playerMana = 0;
      gameState.phase = "idle";

      logEl.innerHTML = "";
      logLine("Inizio partita.");
      // Mano iniziale: 7
      drawCards(7);
      startPlayerTurn();
      render();
    }

    function startPlayerTurn() {
      gameState.currentSide = "player";
      logLine("");
      logLine(`— TURNO ${gameState.globalTurn} (GIOCATORE) —`, true);

      // INIZIO TURNO → effetti come Ringiovanimento
      processStartOfTurnEffects();

      // Pescata
      gameState.phase = "draw";
      updateUIPhase();
      drawCards(3);

      // Mana pieno
      gameState.playerMana = gameState.playerManaMax;

      // Fase giocata carte
      gameState.phase = "play";
      gameState.pendingPlays = [];
      document.getElementById("btnResolve").disabled = true;
      document.getElementById("btnResetTurn").disabled = true;
      updateUIPhase();
      render();
    }

    function endPlayerTurnAndResolve() {
      if (gameState.phase !== "play") return;
      gameState.phase = "resolve";
      updateUIPhase();

      if (gameState.pendingPlays.length === 0) {
        logLine("Nessuna carta da risolvere, passi il turno.");
      } else {
        gameState.pendingPlays.forEach(play => {
          const { card, sourceId, targetIds } = play;
          const source = findCharById(sourceId);
          let targets;
          if (card.target === "allyAll") {
            targets = getTeam(source.side);
          } else if (card.target === "enemyAll") {
            targets = getOpposingTeam(source.side);
          } else {
            targets = targetIds.map(id => findCharById(id)).filter(t => t && t.alive);
          }
          if (!source || !source.alive) return;
          logLine(`>> ${source.name} usa "${card.name}"`);
          try {
            card.effect(source, targets);
          } catch (e) {
            console.error(e);
            logLine(`(Errore nell'effetto di ${card.name})`);
          }
        });
      }

      gameState.pendingPlays = [];
      document.getElementById("pendingPlaysList").textContent = "(nessuna)";

      // FINE TURNO GIOCATORE → Ferita, tick durate, ecc.
      processEndOfTurnEffects();
      render();

      // poi turno bot (turno globale +1)
      gameState.globalTurn += 1;
      setTimeout(startBotTurn, 300);
    }

    function startBotTurn() {
      gameState.currentSide = "bot";
      gameState.phase = "enemy";
      updateUIPhase();
      logLine("");
      logLine(`— TURNO ${gameState.globalTurn} (BOT) —`, true);

      // INIZIO TURNO BOT → Ringiovanimento su entrambi i lati, ecc.
      processStartOfTurnEffects();
      render();

      const aliveBot = gameState.botTeam.filter(c => c.alive);
      const alivePlayer = gameState.playerTeam.filter(c => c.alive);
      if (aliveBot.length === 0 || alivePlayer.length === 0) {
        endGameCheck();
        return;
      }

      const attacker = aliveBot[Math.floor(Math.random() * aliveBot.length)];
      const target = alivePlayer[Math.floor(Math.random() * alivePlayer.length)];

      logLine(`${attacker.name} attacca ${target.name} (bot base attack).`);
      simpleAttack(attacker, target, 0.50);

      // FINE TURNO BOT → Ferita, durate
      processEndOfTurnEffects();
      render();

      if (endGameCheck()) return;

      // dopo il bot → turno globale successivo tuo
      gameState.globalTurn += 1;
      startPlayerTurn();
    }

    function endGameCheck() {
      const playerAlive = gameState.playerTeam.some(c => c.alive);
      const botAlive = gameState.botTeam.some(c => c.alive);
      if (!playerAlive || !botAlive) {
        logLine("");
        if (playerAlive && !botAlive) {
          logLine("HAI VINTO!", true);
        } else if (!playerAlive && botAlive) {
          logLine("HAI PERSO!", true);
        } else {
          logLine("PAREGGIO (tutti i PG sconfitti).", true);
        }
        gameState.phase = "ended";
        updateUIPhase();
        return true;
      }
      return false;
    }

    /****************************************************
     * GIOCO CARTE & TARGET
     ****************************************************/

    function onCardClick(cardId) {
      if (gameState.phase !== "play") return;
      const card = gameState.playerHand.find(c => c.id === cardId);
      if (!card) return;
      if (card.cost > gameState.playerMana) {
        alert("Mana insufficiente per giocare questa carta.");
        return;
      }

      const source = gameState.playerTeam.find(c => c.name === card.owner);
      if (!source || !source.alive) {
        alert("Il personaggio che dovrebbe usare questa carta non è disponibile.");
        return;
      }

      // scala mana subito
      gameState.playerMana -= card.cost;

      const targetType = card.target;
      gameState.selectedCardId = card.id;
      gameState.selectedTargets = [];
      gameState.targetMode = targetType;

      if (targetType === "allyAll" || targetType === "enemyAll") {
        gameState.pendingPlays.push({
          card,
          sourceId: source.id,
          targetIds: []
        });
        logLine(`Hai messo in coda "${card.name}" (bersaglio: ${targetType}).`);
        moveCardFromHandToDiscard(card.id);
        updatePendingListUI();
        document.getElementById("btnResolve").disabled = false;
        document.getElementById("btnResetTurn").disabled = false;
        render();
      } else {
        // serve target singolo
        gameState.mustSelectTarget = true;
        gameState.targetSide = (targetType === "allySingle" ? "player" : "bot");
        logLine(`Seleziona il bersaglio per "${card.name}".`);
        document.getElementById("btnResolve").disabled = false;
        document.getElementById("btnResetTurn").disabled = false;
        render();
      }
    }

    function moveCardFromHandToDiscard(cardId) {
      const idx = gameState.playerHand.findIndex(c => c.id === cardId);
      if (idx >= 0) {
        const [card] = gameState.playerHand.splice(idx, 1);
        gameState.playerDiscard.push(card);
      }
    }

    function onCharacterClick(charId, side) {
      if (!gameState.mustSelectTarget) return;
      if (gameState.targetSide !== side) {
        alert("Questa carta può essere usata solo su un personaggio del lato corretto.");
        return;
      }
      const card = allCards.find(c => c.id === gameState.selectedCardId);
      if (!card) return;

      const source = gameState.playerTeam.find(c => c.name === card.owner);
      if (!source || !source.alive) {
        alert("Sorgente non valida.");
        return;
      }

      gameState.pendingPlays.push({
        card,
        sourceId: source.id,
        targetIds: [charId]
      });
      logLine(`Hai messo in coda "${card.name}" su ${findCharById(charId).name}.`);

      moveCardFromHandToDiscard(card.id);

      gameState.selectedCardId = null;
      gameState.selectedTargets = [];
      gameState.mustSelectTarget = false;
      gameState.targetMode = null;
      gameState.targetSide = null;

      updatePendingListUI();
      render();
    }

    function updatePendingListUI() {
      const el = document.getElementById("pendingPlaysList");
      if (gameState.pendingPlays.length === 0) {
        el.textContent = "(nessuna)";
        return;
      }
      el.textContent = gameState.pendingPlays
        .map((p, idx) => {
          const cardName = p.card.name;
          let targetsText = "";
          if (p.card.target === "allyAll") targetsText = "→ tutti alleati";
          else if (p.card.target === "enemyAll") targetsText = "→ tutti nemici";
          else if (p.targetIds && p.targetIds.length > 0) {
            targetsText = "→ " + p.targetIds.map(id => findCharById(id).name).join(", ");
          }
          return `${idx + 1}) ${cardName} ${targetsText}`;
        })
        .join("\n");
    }

    function resetTurnSelection() {
      if (gameState.phase !== "play") return;
      let manaRefund = 0;
      gameState.pendingPlays.forEach(p => {
        manaRefund += p.card.cost;
        gameState.playerHand.push(p.card);
        const idx = gameState.playerDiscard.findIndex(c => c.id === p.card.id);
        if (idx >= 0) gameState.playerDiscard.splice(idx, 1);
      });
      gameState.playerMana += manaRefund;
      gameState.pendingPlays = [];
      gameState.selectedCardId = null;
      gameState.selectedTargets = [];
      gameState.mustSelectTarget = false;
      gameState.targetMode = null;
      gameState.targetSide = null;
      document.getElementById("pendingPlaysList").textContent = "(nessuna)";
      logLine("Selezione del turno resettata.");
      document.getElementById("btnResolve").disabled = true;
      document.getElementById("btnResetTurn").disabled = true;
      render();
    }

    /****************************************************
     * RENDER UI
     ****************************************************/

    function render() {
      document.getElementById("turnNumber").textContent = gameState.globalTurn;
      document.getElementById("playerMana").textContent = gameState.playerMana;
      document.getElementById("deckCount").textContent = gameState.playerDeck.length;
      document.getElementById("discardCount").textContent = gameState.playerDiscard.length;

      renderTeam("playerTeam", gameState.playerTeam);
      renderTeam("botTeam", gameState.botTeam, true);
      renderHand();
    }

    function renderTeam(containerId, team, isEnemy = false) {
      const container = document.getElementById(containerId);
      container.innerHTML = "";
      team.forEach(ch => {
        const div = document.createElement("div");
        div.className = "char-card" + (isEnemy ? " enemy" : "");
        const name = document.createElement("div");
        name.className = "char-name";
        name.textContent = ch.name + (ch.alive ? "" : " (KO)");
        div.appendChild(name);

        const hpBar = document.createElement("div");
        hpBar.className = "hp-bar";
        const hpFill = document.createElement("div");
        hpFill.className = "hp-fill";
        const ratio = ch.current.lp / ch.current.lpMax;
        hpFill.style.width = (Math.max(0, Math.min(1, ratio)) * 100) + "%";
        hpBar.appendChild(hpFill);
        div.appendChild(hpBar);

        const stat = document.createElement("div");
        stat.className = "stat-line";
        stat.innerHTML =
          `LP: ${ch.current.lp}/${ch.current.lpMax}` +
          ` — ATK: ${ch.current.atk} — DEF: ${ch.current.def}` +
          `<br/>Scudo: ${ch.shield}`;
        div.appendChild(stat);

        if (ch.buffs.length > 0) {
          const buffs = document.createElement("div");
          buffs.className = "buff-tags";
          ch.buffs.forEach(b => {
            if (!VISIBLE_BUFFS.includes(b.keyword)) return;
            const t = document.createElement("span");
            t.className = "tag buff";
            t.textContent = `${b.keyword} x${b.stacks} (${b.remainingTurns})`;
            buffs.appendChild(t);
          });
          if (buffs.children.length > 0) div.appendChild(buffs);
        }

        if (ch.debuffs.length > 0) {
          const debuffs = document.createElement("div");
          debuffs.className = "debuff-tags";
          ch.debuffs.forEach(d => {
            if (!VISIBLE_DEBUFFS.includes(d.keyword)) return;
            const t = document.createElement("span");
            t.className = "tag debuff";
            t.textContent = `${d.keyword} x${d.stacks} (${d.remainingTurns})`;
            debuffs.appendChild(t);
          });
          if (debuffs.children.length > 0) div.appendChild(debuffs);
        }

        div.addEventListener("click", () => onCharacterClick(ch.id, ch.side));
        container.appendChild(div);
      });
    }

    function renderHand() {
      const handEl = document.getElementById("playerHand");
      handEl.innerHTML = "";
      gameState.playerHand.forEach(card => {
        const btn = document.createElement("button");
        btn.className = "card-btn player";
        btn.addEventListener("click", () => onCardClick(card.id));

        const name = document.createElement("div");
        name.className = "card-name";
        name.textContent = card.name;
        btn.appendChild(name);

        const owner = document.createElement("div");
        owner.className = "card-owner";
        owner.textContent = `PG: ${card.owner}`;
        btn.appendChild(owner);

        const cost = document.createElement("div");
        cost.className = "card-cost";
        cost.textContent = card.cost;
        btn.appendChild(cost);

        const desc = document.createElement("div");
        desc.className = "card-desc";
        desc.textContent = card.desc;
        btn.appendChild(desc);

        handEl.appendChild(btn);
      });
    }

    function updateUIPhase() {
      const phaseLabel = document.getElementById("phaseLabel");
      let text = "";
      switch (gameState.phase) {
        case "draw": text = "Pescata"; break;
        case "play": text = "Giocata carte"; break;
        case "resolve": text = "Risoluzione carte"; break;
        case "enemy": text = "Turno del Bot"; break;
        case "ended": text = "Partita terminata"; break;
        default: text = "-";
      }
      phaseLabel.textContent = text;
    }

    /****************************************************
     * EVENTI
     ****************************************************/

    document.getElementById("btnResolve").addEventListener("click", () => {
      endPlayerTurnAndResolve();
      document.getElementById("btnResolve").disabled = true;
      document.getElementById("btnResetTurn").disabled = true;
    });

    document.getElementById("btnResetTurn").addEventListener("click", () => {
      resetTurnSelection();
    });

    /****************************************************
     * AVVIO
     ****************************************************/

    startGame();
  </script>
</body>
</html>
