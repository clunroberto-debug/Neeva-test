<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Neeva — Core Combat Test</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
    }
    header {
      padding: 10px 16px;
      background: #020617;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      font-size: 18px;
      margin: 0;
    }
    header small {
      color: #9ca3af;
    }
    main {
      padding: 12px;
      display: grid;
      grid-template-columns: 1.4fr 0.6fr;
      gap: 12px;
    }
    .column {
      background: #020617;
      border-radius: 8px;
      padding: 10px;
      border: 1px solid #1f2937;
    }
    .section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
      border-bottom: 1px solid #1f2937;
      padding-bottom: 4px;
    }
    .team {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .char-card {
      background: #111827;
      border-radius: 6px;
      padding: 6px;
      border: 1px solid #374151;
      width: 180px;
      cursor: pointer;
      transition: box-shadow 0.15s, transform 0.1s;
    }
    .char-card.enemy {
      border-color: #7f1d1d;
    }
    .char-card.ally {
      border-color: #2563eb;
    }
    .char-card.selected-attacker {
      box-shadow: 0 0 0 2px #22c55e;
      transform: translateY(-1px);
    }
    .char-card.selected-target {
      box-shadow: 0 0 0 2px #f97316;
      transform: translateY(-1px);
    }
    .char-name {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 2px;
    }
    .hp-bar {
      height: 6px;
      background: #1f2937;
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 4px;
    }
    .hp-fill {
      height: 100%;
      background: #22c55e;
    }
    .stat-line {
      font-size: 11px;
      color: #9ca3af;
      line-height: 1.3;
    }
    .small-label {
      font-size: 11px;
      color: #9ca3af;
    }
    .controls {
      margin-top: 8px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }
    button {
      background: #1d4ed8;
      border: none;
      color: white;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    button.secondary {
      background: #374151;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .log {
      font-size: 11px;
      max-height: 400px;
      overflow-y: auto;
      background: #020617;
      border-radius: 6px;
      border: 1px solid #1f2937;
      padding: 6px;
      white-space: pre-line;
    }
    .log-line {
      margin-bottom: 2px;
    }
    .log-turn {
      color: #60a5fa;
      font-weight: 600;
    }
    .log-crit {
      color: #fbbf24;
      font-weight: 600;
    }
    .mana-label {
      font-size: 12px;
      margin-bottom: 4px;
    }
    .turn-info {
      font-size: 12px;
      margin-bottom: 6px;
      color: #e5e7eb;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Neeva — Core Combat Test</h1>
      <small>Solo stat & crit, nessun deck, nessun buff</small>
    </div>
    <div style="font-size:12px;color:#9ca3af">
      Turno globale: <strong><span id="turnNumber">1</span></strong>
      — Lato attivo: <strong><span id="currentSideLabel">Player</span></strong>
    </div>
  </header>

  <main>
    <!-- COLONNA SINISTRA: Campo + controlli -->
    <div class="column">
      <div class="section-title">Campo di Battaglia</div>

      <div class="turn-info">
        Seleziona un <strong>attaccante</strong> dal tuo lato, poi un <strong>bersaglio</strong> avversario, quindi premi
        <strong>"Esegui attacco"</strong>.
      </div>

      <div>
        <div style="font-size:12px;font-weight:600;margin-bottom:2px;">Il tuo team</div>
        <div class="team" id="playerTeam"></div>
      </div>

      <div>
        <div style="font-size:12px;font-weight:600;margin:6px 0 2px;">Team avversario</div>
        <div class="team" id="botTeam"></div>
      </div>

      <div class="controls">
        <button id="btnAttack" disabled>Esegui attacco</button>
        <button id="btnEndTurn" class="secondary">Fine turno (senza attacco)</button>
        <span class="small-label">
          Attaccante: <strong><span id="attackerLabel">-</span></strong> —
          Bersaglio: <strong><span id="targetLabel">-</span></strong>
        </span>
      </div>
    </div>

    <!-- COLONNA DESTRA: Log -->
    <div class="column">
      <div class="section-title">Log di combattimento</div>
      <div id="log" class="log"></div>
    </div>
  </main>

  <script>
    /****************************************************
     * MODELLO BASE DI COMBATTIMENTO (NESSUN DECK)
     ****************************************************/

    const gameState = {
      globalTurn: 1,         // 1 = Player, 2 = Bot, 3 = Player, ecc.
      currentSide: "player", // "player" | "bot"
      playerTeam: [],
      botTeam: [],
      selectedAttackerId: null,
      selectedTargetId: null
    };

    /****************************************************
     * CREAZIONE PERSONAGGI
     ****************************************************/

    function createCharacter(id, name, side, stats) {
      return {
        id,
        name,
        side, // "player" | "bot"
        base: { ...stats },
        current: { ...stats },
        alive: true
      };
    }

    function initTeams() {
      // Usa i valori definitivi che hai dato
      gameState.playerTeam = [
        createCharacter("basil", "Basil", "player", {
          lp: 980, lpMax: 980, atk: 63, def: 27,
          critChance: 60, critDmg: 120,
          critResist: 22, critDef: 47
        }),
        createCharacter("gael", "Gael", "player", {
          lp: 900, lpMax: 900, atk: 72, def: 11,
          critChance: 30, critDmg: 150,
          critResist: 10, critDef: 25
        }),
        createCharacter("zagrok", "Zagrok", "player", {
          lp: 830, lpMax: 830, atk: 68, def: 13,
          critChance: 30, critDmg: 150,
          critResist: 30, critDef: 20
        })
      ];

      gameState.botTeam = [
        createCharacter("mordel", "Mordel", "bot", {
          lp: 1020, lpMax: 1020, atk: 60, def: 32,
          critChance: 25, critDmg: 150,
          critResist: 25, critDef: 33
        }),
        createCharacter("kiddou", "Kiddou", "bot", {
          lp: 820, lpMax: 820, atk: 58, def: 23,
          critChance: 40, critDmg: 160,
          critResist: 20, critDef: 26
        }),
        createCharacter("rindu", "Rindu", "bot", {
          lp: 860, lpMax: 860, atk: 78, def: 28,
          critChance: 28, critDmg: 150,
          critResist: 20, critDef: 22
        })
      ];
    }

    /****************************************************
     * LOG
     ****************************************************/

    const logEl = document.getElementById("log");

    function logLine(text, cssClass = "") {
      const div = document.createElement("div");
      div.className = "log-line " + cssClass;
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    /****************************************************
     * COMBATTIMENTO CON CRIT
     ****************************************************/

    /**
     * Calcola danno con crit e difese.
     * vc = value coefficient (per ora 1.0 = attacco pieno).
     * Ritorna un oggetto con info utili per il log.
     */
    function computeDamage(attacker, defender, vc = 1.0) {
      const base = Math.round(attacker.current.atk * vc);

      // Crit chance effettiva
      const effectiveCritChance = Math.max(
        0,
        (attacker.current.critChance || 0) - (defender.current.critResist || 0)
      );

      const roll = Math.floor(Math.random() * 100) + 1;
      const isCrit = effectiveCritChance > 0 && roll <= effectiveCritChance;

      let rawAfterMult;
      let mitigated;
      if (isCrit) {
        const critMult = (attacker.current.critDmg || 100) / 100;
        rawAfterMult = Math.round(base * critMult);
        mitigated = Math.max(0, rawAfterMult - (defender.current.critDef || defender.current.def || 0));
      } else {
        rawAfterMult = base;
        mitigated = Math.max(0, rawAfterMult - (defender.current.def || 0));
      }

      return {
        base,
        roll,
        effectiveCritChance,
        isCrit,
        rawAfterMult,
        dmg: mitigated
      };
    }

    function performAttack(attacker, defender) {
      if (!attacker.alive || !defender.alive) return;

      // Per ora VC fisso 1.0 (in futuro useremo la VC della carta)
      const result = computeDamage(attacker, defender, 1.0);
      const { base, roll, effectiveCritChance, isCrit, rawAfterMult, dmg } = result;

      const critText = isCrit
        ? `CRITICO! roll ${roll} ≤ ${effectiveCritChance}%`
        : `colpo normale (roll ${roll} > ${effectiveCritChance}%)`;

      logLine(
        `${attacker.name} attacca ${defender.name}: base=${base}, dopo moltiplicatore=${rawAfterMult}, danno finale=${dmg} — ${critText}`,
        isCrit ? "log-crit" : ""
      );

      if (dmg > 0) {
        defender.current.lp = Math.max(0, defender.current.lp - dmg);
        if (defender.current.lp === 0) {
          defender.alive = false;
          logLine(`${defender.name} è stato sconfitto!`);
        }
      } else {
        logLine(`${defender.name} non subisce danni.`);
      }

      render();
      checkEndGame();
    }

    /****************************************************
     * TURNI
     ****************************************************/

    function startGame() {
      initTeams();
      gameState.globalTurn = 1;
      gameState.currentSide = "player";
      gameState.selectedAttackerId = null;
      gameState.selectedTargetId = null;

      logEl.innerHTML = "";
      logLine("Inizio partita.");
      logLine(`Turno 1 — tocca al Giocatore.`, "log-turn");

      render();
    }

    function nextTurn() {
      // alternanza lato
      if (gameState.currentSide === "player") {
        gameState.currentSide = "bot";
      } else {
        gameState.currentSide = "player";
        gameState.globalTurn += 1;
      }

      gameState.selectedAttackerId = null;
      gameState.selectedTargetId = null;

      const labelSide = gameState.currentSide === "player" ? "Giocatore" : "Bot";
      logLine("");
      logLine(`Turno ${gameState.globalTurn} — tocca a ${labelSide}.`, "log-turn");

      render();

      if (gameState.currentSide === "bot") {
        botAutoTurn();
      }
    }

    function checkEndGame() {
      const playerAlive = gameState.playerTeam.some(c => c.alive);
      const botAlive = gameState.botTeam.some(c => c.alive);

      if (!playerAlive || !botAlive) {
        const msg =
          !playerAlive && !botAlive
            ? "Pareggio: tutti i personaggi sono stati sconfitti."
            : playerAlive
              ? "VITTORIA del Giocatore!"
              : "VITTORIA del Bot!";
        logLine("");
        logLine(msg, "log-turn");
        // In questa versione base non blocchiamo i click, ma la partita è "finita".
      }
    }

    /****************************************************
     * TURNO AUTOMATICO BOT
     ****************************************************/

    function botAutoTurn() {
      const aliveBot = gameState.botTeam.filter(c => c.alive);
      const alivePlayer = gameState.playerTeam.filter(c => c.alive);

      if (aliveBot.length === 0 || alivePlayer.length === 0) {
        checkEndGame();
        return;
      }

      const attacker =
        aliveBot[Math.floor(Math.random() * aliveBot.length)];
      const target =
        alivePlayer[Math.floor(Math.random() * alivePlayer.length)];

      logLine(`(Bot) ${attacker.name} sceglie come bersaglio ${target.name}.`);

      performAttack(attacker, target);

      // Poi passa al turno del giocatore
      nextTurn();
    }

    /****************************************************
     * SELEZIONE ATTACCANTE / BERSAGLIO (SOLO PLAYER)
     ****************************************************/

    function onCharacterClick(charId, side) {
      if (gameState.currentSide !== "player") return; // il player può agire solo nel suo turno
      const ch = findCharById(charId);
      if (!ch || !ch.alive) return;

      if (side === "player") {
        // seleziono attaccante
        gameState.selectedAttackerId = charId;
      } else {
        // seleziono bersaglio
        gameState.selectedTargetId = charId;
      }

      updateAttackButtonState();
      render();
    }

    function findCharById(id) {
      return (
        gameState.playerTeam.find(c => c.id === id) ||
        gameState.botTeam.find(c => c.id === id)
      );
    }

    function updateAttackButtonState() {
      const btn = document.getElementById("btnAttack");
      const attacker = findCharById(gameState.selectedAttackerId);
      const target = findCharById(gameState.selectedTargetId);

      if (
        gameState.currentSide === "player" &&
        attacker &&
        attacker.alive &&
        target &&
        target.alive &&
        attacker.side === "player" &&
        target.side === "bot"
      ) {
        btn.disabled = false;
      } else {
        btn.disabled = true;
      }

      document.getElementById("attackerLabel").textContent =
        attacker && attacker.alive ? attacker.name : "-";
      document.getElementById("targetLabel").textContent =
        target && target.alive ? target.name : "-";
    }

    /****************************************************
     * RENDER UI
     ****************************************************/

    function render() {
      document.getElementById("turnNumber").textContent = gameState.globalTurn;
      document.getElementById("currentSideLabel").textContent =
        gameState.currentSide === "player" ? "Player" : "Bot";

      renderTeam("playerTeam", gameState.playerTeam, "player");
      renderTeam("botTeam", gameState.botTeam, "bot");
      updateAttackButtonState();
    }

    function renderTeam(containerId, team, side) {
      const container = document.getElementById(containerId);
      container.innerHTML = "";

      team.forEach(ch => {
        const div = document.createElement("div");
        div.className =
          "char-card " +
          (side === "player" ? "ally" : "enemy");

        if (ch.id === gameState.selectedAttackerId) {
          div.classList.add("selected-attacker");
        }
        if (ch.id === gameState.selectedTargetId) {
          div.classList.add("selected-target");
        }

        const name = document.createElement("div");
        name.className = "char-name";
        name.textContent = ch.name + (ch.alive ? "" : " (KO)");
        div.appendChild(name);

        const hpBar = document.createElement("div");
        hpBar.className = "hp-bar";
        const hpFill = document.createElement("div");
        hpFill.className = "hp-fill";
        const ratio = ch.current.lp / ch.current.lpMax;
        hpFill.style.width = (Math.max(0, Math.min(1, ratio)) * 100) + "%";
        hpBar.appendChild(hpFill);
        div.appendChild(hpBar);

        const stat = document.createElement("div");
        stat.className = "stat-line";
        stat.innerHTML =
          `LP: ${ch.current.lp}/${ch.current.lpMax}` +
          `<br/>ATK: ${ch.current.atk} — DEF: ${ch.current.def}` +
          `<br/>Crit: ${ch.current.critChance}% / ${ch.current.critDmg}%` +
          `<br/>CritRes: ${ch.current.critResist}% — CritDef: ${ch.current.critDef}`;
        div.appendChild(stat);

        div.addEventListener("click", () => onCharacterClick(ch.id, side));
        container.appendChild(div);
      });
    }

    /****************************************************
     * EVENTI BOTTONI
     ****************************************************/

    document.getElementById("btnAttack").addEventListener("click", () => {
      if (gameState.currentSide !== "player") return;
      const attacker = findCharById(gameState.selectedAttackerId);
      const target = findCharById(gameState.selectedTargetId);
      if (!attacker || !target || !attacker.alive || !target.alive) return;

      performAttack(attacker, target);

      // Dopo l'attacco, passa il turno
      nextTurn();
    });

    document.getElementById("btnEndTurn").addEventListener("click", () => {
      // Passa il turno senza attaccare
      nextTurn();
    });

    /****************************************************
     * AVVIO
     ****************************************************/

    startGame();
  </script>
</body>
</html>
